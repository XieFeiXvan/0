.TH "HiEasyX::Canvas" 3 "2023年 一月 13日 星期五" "Version Ver 0.3.0" "HiEasyX" \" -*- nroff -*-
.ad l
.nh
.SH NAME
HiEasyX::Canvas \- 画布  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <HiCanvas\&.h>\fP
.PP
继承自 IMAGE \&.
.SS "Public 成员函数"

.in +1c
.ti -1c
.RI "\fBCanvas\fP ()"
.br
.ti -1c
.RI "\fBCanvas\fP (int w, int h, COLORREF cBk=BLACK)"
.br
.ti -1c
.RI "\fBCanvas\fP (IMAGE *pImg)"
.br
.RI "复制图像内容（绑定图像指针请调用 BindToImage） "
.ti -1c
.RI "\fBCanvas\fP (IMAGE img)"
.br
.ti -1c
.RI "\fBCanvas\fP & \fBoperator=\fP (IMAGE *pImg)"
.br
.RI "复制图像内容（绑定图像指针请调用 BindToImage） "
.ti -1c
.RI "\fBCanvas\fP & \fBoperator=\fP (IMAGE img)"
.br
.ti -1c
.RI "void \fBUpdateSizeInfo\fP ()"
.br
.ti -1c
.RI "void \fBResize\fP (int w, int h) override"
.br
.RI "重设画布大小（若绑定了窗口，则不建议调用） "
.ti -1c
.RI "\fBCanvas\fP & \fBBindToImage\fP (IMAGE *pImg)"
.br
.ti -1c
.RI "IMAGE * \fBGetImagePointer\fP ()"
.br
.ti -1c
.RI "IMAGE * \fBPt\fP ()"
.br
.RI "等价于 \fBGetImagePointer()\fP "
.ti -1c
.RI "DWORD * \fBGetBuffer\fP () const"
.br
.RI "获取图像缓冲区指针 "
.ti -1c
.RI "int \fBGetBufferSize\fP () const"
.br
.RI "获取图像缓冲区大小，即图像面积（宽 * 高） "
.ti -1c
.RI "HDC \fBGetHDC\fP ()"
.br
.RI "获取画布的 HDC "
.ti -1c
.RI "int \fBgetwidth\fP () const"
.br
.ti -1c
.RI "int \fBgetheight\fP () const"
.br
.ti -1c
.RI "int \fBGetWidth\fP () const"
.br
.ti -1c
.RI "int \fBGetHeight\fP () const"
.br
.ti -1c
.RI "void \fBEnableAutoMarkFlushWindow\fP (bool enable)"
.br
.ti -1c
.RI "bool \fBIsEnableAutoMarkFlushWindow\fP () const"
.br
.ti -1c
.RI "void \fBBeginBatchDrawing\fP ()"
.br
.ti -1c
.RI "void \fBEndBatchDrawing\fP ()"
.br
.ti -1c
.RI "bool \fBIsValidPoint\fP (int x, int y, int *pIndex=nullptr)"
.br
.RI "判断某点是否位于图像中 "
.ti -1c
.RI "void \fBClear\fP (bool isSetColor=false, COLORREF bkcolor=BLACK)"
.br
.ti -1c
.RI "void \fBClear_Alpha\fP (bool isSetColor=false, COLORREF bkcolor=BLACK, bool ignore_alpha=false)"
.br
.RI "用背景色清空画布（区别于 Clear 函数，此函数默认保留背景色中的透明度） "
.ti -1c
.RI "LINESTYLE \fBGetLineStyle\fP ()"
.br
.ti -1c
.RI "void \fBSetLineStyle\fP (LINESTYLE style)"
.br
.ti -1c
.RI "void \fBSetLineStyle\fP (int style, int thickness=1, const DWORD *puserstyle=nullptr, DWORD userstylecount=0)"
.br
.ti -1c
.RI "void \fBSetLineThickness\fP (int thickness)"
.br
.ti -1c
.RI "int \fBGetLineThickness\fP ()"
.br
.ti -1c
.RI "FILLSTYLE \fBGetFillStyle\fP ()"
.br
.ti -1c
.RI "void \fBSetFillStyle\fP (FILLSTYLE style)"
.br
.ti -1c
.RI "void \fBSetFillStyle\fP (int style, long hatch=0, IMAGE *ppattern=nullptr)"
.br
.ti -1c
.RI "void \fBSetFillStyle\fP (BYTE *ppattern8x8)"
.br
.ti -1c
.RI "int \fBGetRop2\fP ()"
.br
.ti -1c
.RI "void \fBSetRop2\fP (int mode)"
.br
.ti -1c
.RI "int \fBGetPolyFillMode\fP ()"
.br
.ti -1c
.RI "void \fBSetPolyFillMode\fP (int mode)"
.br
.ti -1c
.RI "COLORREF \fBGetLineColor\fP ()"
.br
.ti -1c
.RI "void \fBSetLineColor\fP (COLORREF color)"
.br
.ti -1c
.RI "COLORREF \fBGetTextColor\fP ()"
.br
.ti -1c
.RI "void \fBSetTextColor\fP (COLORREF color)"
.br
.ti -1c
.RI "COLORREF \fBGetFillColor\fP ()"
.br
.ti -1c
.RI "void \fBSetFillColor\fP (COLORREF color)"
.br
.ti -1c
.RI "COLORREF \fBGetBkColor\fP ()"
.br
.ti -1c
.RI "void \fBSetBkColor\fP (COLORREF color)"
.br
.ti -1c
.RI "int \fBGetBkMode\fP ()"
.br
.ti -1c
.RI "void \fBSetBkMode\fP (int mode)"
.br
.ti -1c
.RI "void \fBSetDefault\fP ()"
.br
.RI "设置绘图状态为原始状态 "
.ti -1c
.RI "COLORREF \fBGetPixel\fP (int x, int y)"
.br
.ti -1c
.RI "void \fBPutPixel\fP (int x, int y, COLORREF c)"
.br
.ti -1c
.RI "COLORREF \fBGetPixel_Direct\fP (int x, int y)"
.br
.RI "直接操作显存获取点 "
.ti -1c
.RI "void \fBPutPixel_Direct\fP (int x, int y, COLORREF c)"
.br
.RI "直接操作显存绘制点 "
.ti -1c
.RI "void \fBPutPixel_Direct_Alpha\fP (int x, int y, COLORREF c)"
.br
.RI "直接操作显存绘制带有透明度的点（使用 COLORREF 中的透明度） "
.ti -1c
.RI "void \fBLine\fP (int x1, int y1, int x2, int y2, bool isSetColor=false, COLORREF c=0)"
.br
.ti -1c
.RI "void \fBLine\fP (POINT pt1, POINT pt2, bool isSetColor=false, COLORREF c=0)"
.br
.ti -1c
.RI "void \fBRectangle\fP (int left, int top, int right, int bottom, bool isSetColor=false, COLORREF c=0)"
.br
.ti -1c
.RI "void \fBRectangle\fP (RECT rct, bool isSetColor=false, COLORREF c=0)"
.br
.ti -1c
.RI "void \fBFillRectangle\fP (int left, int top, int right, int bottom, bool isSetColor=false, COLORREF cLine=0, COLORREF cFill=0)"
.br
.ti -1c
.RI "void \fBFillRectangle\fP (RECT rct, bool isSetColor=false, COLORREF cLine=0, COLORREF cFill=0)"
.br
.ti -1c
.RI "void \fBSolidRectangle\fP (int left, int top, int right, int bottom, bool isSetColor=false, COLORREF c=0)"
.br
.ti -1c
.RI "void \fBSolidRectangle\fP (RECT rct, bool isSetColor=false, COLORREF c=0)"
.br
.ti -1c
.RI "void \fBClearRectangle\fP (int left, int top, int right, int bottom)"
.br
.ti -1c
.RI "void \fBClearRectangle\fP (RECT rct)"
.br
.ti -1c
.RI "void \fBCircle\fP (int x, int y, int radius, bool isSetColor=false, COLORREF c=0)"
.br
.ti -1c
.RI "void \fBFillCircle\fP (int x, int y, int radius, bool isSetColor=false, COLORREF cLine=0, COLORREF cFill=0)"
.br
.ti -1c
.RI "void \fBSolidCircle\fP (int x, int y, int radius, bool isSetColor=false, COLORREF c=0)"
.br
.ti -1c
.RI "void \fBClearCircle\fP (int x, int y, int radius)"
.br
.ti -1c
.RI "void \fBEllipse\fP (int left, int top, int right, int bottom, bool isSetColor=false, COLORREF c=0)"
.br
.ti -1c
.RI "void \fBEllipse\fP (RECT rct, bool isSetColor=false, COLORREF c=0)"
.br
.ti -1c
.RI "void \fBFillEllipse\fP (int left, int top, int right, int bottom, bool isSetColor=false, COLORREF cLine=0, COLORREF cFill=0)"
.br
.ti -1c
.RI "void \fBFillEllipse\fP (RECT rct, bool isSetColor=false, COLORREF cLine=0, COLORREF cFill=0)"
.br
.ti -1c
.RI "void \fBSolidEllipse\fP (int left, int top, int right, int bottom, bool isSetColor=false, COLORREF c=0)"
.br
.ti -1c
.RI "void \fBSolidEllipse\fP (RECT rct, bool isSetColor=false, COLORREF c=0)"
.br
.ti -1c
.RI "void \fBClearEllipse\fP (int left, int top, int right, int bottom)"
.br
.ti -1c
.RI "void \fBClearEllipse\fP (RECT rct)"
.br
.ti -1c
.RI "void \fBRoundRect\fP (int left, int top, int right, int bottom, int ellipsewidth, int ellipseheight, bool isSetColor=false, COLORREF c=0)"
.br
.ti -1c
.RI "void \fBRoundRect\fP (RECT rct, int ellipsewidth, int ellipseheight, bool isSetColor=false, COLORREF c=0)"
.br
.ti -1c
.RI "void \fBFillRoundRect\fP (int left, int top, int right, int bottom, int ellipsewidth, int ellipseheight, bool isSetColor=false, COLORREF cLine=0, COLORREF cFill=0)"
.br
.ti -1c
.RI "void \fBFillRoundRect\fP (RECT rct, int ellipsewidth, int ellipseheight, bool isSetColor=false, COLORREF cLine=0, COLORREF cFill=0)"
.br
.ti -1c
.RI "void \fBSolidRoundRect\fP (int left, int top, int right, int bottom, int ellipsewidth, int ellipseheight, bool isSetColor=false, COLORREF c=0)"
.br
.ti -1c
.RI "void \fBSolidRoundRect\fP (RECT rct, int ellipsewidth, int ellipseheight, bool isSetColor=false, COLORREF c=0)"
.br
.ti -1c
.RI "void \fBClearRoundRect\fP (int left, int top, int right, int bottom, int ellipsewidth, int ellipseheight)"
.br
.ti -1c
.RI "void \fBClearRoundRect\fP (RECT rct, int ellipsewidth, int ellipseheight)"
.br
.ti -1c
.RI "void \fBArc\fP (int left, int top, int right, int bottom, double stangle, double endangle, bool isSetColor=false, COLORREF c=0)"
.br
.ti -1c
.RI "void \fBArc\fP (RECT rct, double stangle, double endangle, bool isSetColor=false, COLORREF c=0)"
.br
.ti -1c
.RI "void \fBPie\fP (int left, int top, int right, int bottom, double stangle, double endangle, bool isSetColor=false, COLORREF c=0)"
.br
.ti -1c
.RI "void \fBPie\fP (RECT rct, double stangle, double endangle, bool isSetColor=false, COLORREF c=0)"
.br
.ti -1c
.RI "void \fBFillPie\fP (int left, int top, int right, int bottom, double stangle, double endangle, bool isSetColor=false, COLORREF cLine=0, COLORREF cFill=0)"
.br
.ti -1c
.RI "void \fBFillPie\fP (RECT rct, double stangle, double endangle, bool isSetColor=false, COLORREF cLine=0, COLORREF cFill=0)"
.br
.ti -1c
.RI "void \fBSolidPie\fP (int left, int top, int right, int bottom, double stangle, double endangle, bool isSetColor=false, COLORREF c=0)"
.br
.ti -1c
.RI "void \fBSolidPie\fP (RECT rct, double stangle, double endangle, bool isSetColor=false, COLORREF c=0)"
.br
.ti -1c
.RI "void \fBClearPie\fP (int left, int top, int right, int bottom, double stangle, double endangle)"
.br
.ti -1c
.RI "void \fBClearPie\fP (RECT rct, double stangle, double endangle)"
.br
.ti -1c
.RI "void \fBPolyline\fP (const POINT *points, int num, bool isSetColor=false, COLORREF c=0)"
.br
.ti -1c
.RI "void \fBPolygon\fP (const POINT *points, int num, bool isSetColor=false, COLORREF c=0)"
.br
.ti -1c
.RI "void \fBFillPolygon\fP (const POINT *points, int num, bool isSetColor=false, COLORREF cLine=0, COLORREF cFill=0)"
.br
.ti -1c
.RI "void \fBSolidPolygon\fP (const POINT *points, int num, bool isSetColor=false, COLORREF c=0)"
.br
.ti -1c
.RI "void \fBClearPolygon\fP (const POINT *points, int num)"
.br
.ti -1c
.RI "void \fBPolyBezier\fP (const POINT *points, int num, bool isSetColor=false, COLORREF c=0)"
.br
.ti -1c
.RI "void \fBFloodFill\fP (int x, int y, COLORREF color, int filltype=FLOODFILLBORDER, bool isSetColor=false, COLORREF cFill=0)"
.br
.RI "填充某区域 "
.ti -1c
.RI "int \fBOutTextXY\fP (int x, int y, LPCTSTR lpszText, bool isSetColor=false, COLORREF c=0)"
.br
.RI "在指定位置输出文本 "
.ti -1c
.RI "int \fBOutTextXY\fP (int x, int y, TCHAR ch, bool isSetColor=false, COLORREF c=0)"
.br
.ti -1c
.RI "int \fBOutTextXY_Format\fP (int x, int y, int _Size, LPCTSTR _Format,\&.\&.\&.)"
.br
.RI "在指定位置输出格式化文本 "
.ti -1c
.RI "int \fBTextWidth\fP (LPCTSTR lpszText)"
.br
.RI "获取文本像素宽度 "
.ti -1c
.RI "int \fBTextWidth\fP (TCHAR c)"
.br
.ti -1c
.RI "int \fBTextHeight\fP (LPCTSTR lpszText)"
.br
.ti -1c
.RI "int \fBTextHeight\fP (TCHAR c)"
.br
.ti -1c
.RI "int \fBDraw_Text\fP (LPCTSTR str, RECT *pRect, UINT uFormat, bool isSetColor=false, COLORREF c=0)"
.br
.ti -1c
.RI "int \fBDraw_Text\fP (TCHAR ch, RECT *pRect, UINT uFormat, bool isSetColor=false, COLORREF c=0)"
.br
.ti -1c
.RI "void \fBCenterText\fP (LPCTSTR lpszText, RECT rct={ \-1 }, bool isSetColor=false, COLORREF c=0)"
.br
.RI "在某区域居中输出文字 "
.ti -1c
.RI "void \fBCenterText_Format\fP (int _Size, LPCTSTR _Format,\&.\&.\&.)"
.br
.RI "居中输出格式化文本 "
.ti -1c
.RI "LOGFONT \fBGetTextStyle\fP ()"
.br
.ti -1c
.RI "void \fBSetTextStyle\fP (int nHeight, int nWidth, LPCTSTR lpszFace)"
.br
.ti -1c
.RI "void \fBSetTextStyle\fP (int nHeight, int nWidth, LPCTSTR lpszFace, int nEscapement, int nOrientation, int nWeight, bool bItalic, bool bUnderline, bool bStrikeOut)"
.br
.ti -1c
.RI "void \fBSetTextStyle\fP (int nHeight, int nWidth, LPCTSTR lpszFace, int nEscapement, int nOrientation, int nWeight, bool bItalic, bool bUnderline, bool bStrikeOut, BYTE fbCharSet, BYTE fbOutPrecision, BYTE fbClipPrecision, BYTE fbQuality, BYTE fbPitchAndFamily)"
.br
.ti -1c
.RI "void \fBSetTextStyle\fP (LOGFONT font)"
.br
.ti -1c
.RI "void \fBSetFont\fP (int nHeight, int nWidth=0)"
.br
.RI "设置字体大小 "
.ti -1c
.RI "void \fBSetTypeface\fP (LPCTSTR lpsz)"
.br
.RI "设置使用字体的名称 "
.ti -1c
.RI "void \fBSetTextEscapement\fP (LONG lfEscapement)"
.br
.RI "设置字符串的书写角度（单位 0\&.1 度） "
.ti -1c
.RI "void \fBSetTextOrientation\fP (LONG lfOrientation)"
.br
.RI "设置每个字符的书写角度（单位 0\&.1 度） "
.ti -1c
.RI "void \fBSetTextWeight\fP (LONG lfWeight)"
.br
.RI "设置字符的笔画粗细（范围 默认 0 ~ 1000 最粗） "
.ti -1c
.RI "void \fBSetTextItalic\fP (bool lfItalic)"
.br
.RI "设置字体是否为斜体 "
.ti -1c
.RI "void \fBSetTextUnderline\fP (bool lfUnderline)"
.br
.RI "设置字体是否有下划线 "
.ti -1c
.RI "void \fBSetTextStrikeOut\fP (bool lfStrikeOut)"
.br
.RI "设置字体是否有删除线 "
.ti -1c
.RI "COLORREF \fBGetColor\fP ()"
.br
.RI "获取前景色 "
.ti -1c
.RI "void \fBSetColor\fP (COLORREF color)"
.br
.RI "设置前景色 "
.ti -1c
.RI "int \fBGetX\fP ()"
.br
.ti -1c
.RI "int \fBGetY\fP ()"
.br
.ti -1c
.RI "void \fBMoveTo\fP (int x, int y)"
.br
.ti -1c
.RI "void \fBMoveRel\fP (int dx, int dy)"
.br
.ti -1c
.RI "void \fBLineTo\fP (int x, int y, bool isSetColor=false, COLORREF c=0)"
.br
.ti -1c
.RI "void \fBLineRel\fP (int dx, int dy, bool isSetColor=false, COLORREF c=0)"
.br
.ti -1c
.RI "void \fBOutText\fP (LPCTSTR lpszText, bool isSetColor=false, COLORREF c=0)"
.br
.ti -1c
.RI "void \fBOutText\fP (TCHAR ch, bool isSetColor=false, COLORREF c=0)"
.br
.ti -1c
.RI "int \fBOutText_Format\fP (int _Size, LPCTSTR _Format,\&.\&.\&.)"
.br
.RI "输出格式化文本 "
.ti -1c
.RI "IMAGE \fBLoad_Image_Alpha\fP (LPCTSTR lpszImgFile, int x=0, int y=0, bool bResize=true, int nWidth=0, int nHeight=0, BYTE alpha=255, bool bUseSrcAlpha=false)"
.br
.ti -1c
.RI "void \fBPutImageIn_Alpha\fP (int x, int y, IMAGE *pImg, RECT crop={ 0 }, BYTE alpha=255, bool bUseSrcAlpha=false, bool isCalculated=false)"
.br
.RI "绘制图像到该画布 "
.ti -1c
.RI "void \fBRenderTo\fP (int x, int y, IMAGE *pImg=nullptr, RECT crop={ 0 }, BYTE alpha=255, bool bUseSrcAlpha=false, bool isCalculated=false)"
.br
.RI "将该画布的图像绘制到另一画布中 "
.ti -1c
.RI "void \fBRotateImage\fP (double radian, COLORREF bkcolor=BLACK, bool autosize=false, bool highquality=true)"
.br
.RI "EasyX 原生旋转函数 "
.ti -1c
.RI "void \fBRotateImage_Alpha\fP (double radian, COLORREF bkcolor=BLACK)"
.br
.RI "旋转图像（保留 Alpha 信息） "
.ti -1c
.RI "void \fBZoomImage_Rough_Alpha\fP (int nW, int nH=0)"
.br
.RI "缩放图像（粗糙的、即不插值的缩放，保留透明度信息） "
.ti -1c
.RI "void \fBZoomImage_Alpha\fP (int nW, int nH=0)"
.br
.RI "缩放图像（双线性插值，保留透明度信息） "
.ti -1c
.RI "void \fBZoomImage_Win32_Alpha\fP (int nW, int nH=0)"
.br
.RI "缩放图像（基于 Win32 API，比较快，保留透明度信息） "
.ti -1c
.RI "void \fBGP_SetLineColor\fP (COLORREF color)"
.br
.ti -1c
.RI "void \fBGP_SetFillColor\fP (COLORREF color)"
.br
.ti -1c
.RI "void \fBGP_SetLineWidth\fP (float width)"
.br
.ti -1c
.RI "COLORREF \fBGP_GetLineColor\fP () const"
.br
.ti -1c
.RI "COLORREF \fBGP_GetFillColor\fP () const"
.br
.ti -1c
.RI "float \fBGP_GetLineWidth\fP () const"
.br
.ti -1c
.RI "void \fBGP_EnableAlpha\fP (bool enable)"
.br
.RI "设置 GDI+ 绘制时是否使用透明度 "
.ti -1c
.RI "void \fBGP_EnableAA\fP (bool enable)"
.br
.RI "设置 GDI+ 绘制时是否抗锯齿 "
.ti -1c
.RI "bool \fBGP_IsEnbaleAlpha\fP () const"
.br
.ti -1c
.RI "bool \fBGP_IsEnbaleAA\fP () const"
.br
.ti -1c
.RI "void \fBGP_Line\fP (float x1, float y1, float x2, float y2, bool isSetColor=false, COLORREF linecolor=0)"
.br
.ti -1c
.RI "void \fBGP_Polygon\fP (int points_num, POINT *points, bool isSetColor=false, COLORREF linecolor=0)"
.br
.ti -1c
.RI "void \fBGP_SolidPolygon\fP (int points_num, POINT *points, bool isSetColor=false, COLORREF fillcolor=0)"
.br
.ti -1c
.RI "void \fBGP_FillPolygon\fP (int points_num, POINT *points, bool isSetColor=false, COLORREF linecolor=0, COLORREF fillcolor=0)"
.br
.ti -1c
.RI "void \fBGP_Rectangle\fP (float x, float y, float w, float h, bool isSetColor=false, COLORREF linecolor=0)"
.br
.ti -1c
.RI "void \fBGP_SolidRectangle\fP (float x, float y, float w, float h, bool isSetColor=false, COLORREF fillcolor=0)"
.br
.ti -1c
.RI "void \fBGP_FillRectangle\fP (float x, float y, float w, float h, bool isSetColor=false, COLORREF linecolor=0, COLORREF fillcolor=0)"
.br
.ti -1c
.RI "void \fBGP_Ellipse\fP (float x, float y, float w, float h, bool isSetColor=false, COLORREF linecolor=0)"
.br
.ti -1c
.RI "void \fBGP_SolidEllipse\fP (float x, float y, float w, float h, bool isSetColor=false, COLORREF fillcolor=0)"
.br
.ti -1c
.RI "void \fBGP_FillEllipse\fP (float x, float y, float w, float h, bool isSetColor=false, COLORREF linecolor=0, COLORREF fillcolor=0)"
.br
.ti -1c
.RI "void \fBGP_Pie\fP (float x, float y, float w, float h, float stangle, float endangle, bool isSetColor=false, COLORREF linecolor=0)"
.br
.ti -1c
.RI "void \fBGP_SolidPie\fP (float x, float y, float w, float h, float stangle, float endangle, bool isSetColor=false, COLORREF fillcolor=0)"
.br
.ti -1c
.RI "void \fBGP_FillPie\fP (float x, float y, float w, float h, float stangle, float endangle, bool isSetColor=false, COLORREF linecolor=0, COLORREF fillcolor=0)"
.br
.ti -1c
.RI "void \fBGP_Arc\fP (float x, float y, float w, float h, float stangle, float endangle, bool isSetColor=false, COLORREF linecolor=0)"
.br
.in -1c
.SS "Protected 成员函数"

.in +1c
.ti -1c
.RI "void \fBCleanUpSettings\fP ()"
.br
.RI "清空大部分设置 "
.ti -1c
.RI "bool \fBBeginWindowTask\fP ()"
.br
.RI "单独启动 HiWindow 的窗口任务（如果绑定了窗口） "
.ti -1c
.RI "void \fBEndWindowTask\fP ()"
.br
.RI "结束 HiWindow 的窗口任务 "
.ti -1c
.RI "bool \fBBeginDrawing\fP ()"
.br
.ti -1c
.RI "void \fBEndDrawing\fP ()"
.br
.RI "调用 EasyX 绘图函数完毕，恢复先前的绘图状态 "
.ti -1c
.RI "\fBCanvas\fP & \fBBindToWindow\fP (HWND hWnd, IMAGE *pImg)"
.br
.in -1c
.SS "Protected 属性"

.in +1c
.ti -1c
.RI "\fBDrawingProperty\fP \fBm_property\fP"
.br
.RI "保存外界绘图属性（用于保存旧的绘图对象指针） "
.ti -1c
.RI "DWORD * \fBm_pBuf\fP = nullptr"
.br
.RI "图像内存指针 "
.ti -1c
.RI "int \fBm_nWidth\fP"
.br
.ti -1c
.RI "int \fBm_nHeight\fP"
.br
.RI "图像宽高 "
.ti -1c
.RI "int \fBm_nBufSize\fP"
.br
.RI "图像面积 "
.ti -1c
.RI "bool \fBm_bBindToImgPointer\fP"
.br
.RI "该画布是否绑定到图像指针 "
.ti -1c
.RI "IMAGE * \fBm_pImg\fP"
.br
.RI "画布绑定的图像指针（若画布绑定到指针） "
.ti -1c
.RI "bool \fBm_bBatchDraw\fP"
.br
.RI "是否启用了批量绘制 "
.ti -1c
.RI "COLORREF \fBm_cGPLineColor\fP = WHITE"
.br
.RI "GDI+ 绘图时使用的线条颜色 "
.ti -1c
.RI "COLORREF \fBm_cGPFillColor\fP = WHITE"
.br
.RI "GDI+ 绘图时使用的填充颜色 "
.ti -1c
.RI "float \fBm_fGPLineWidth\fP = 1\&.f"
.br
.RI "GDI+ 绘图时的线条宽度 "
.ti -1c
.RI "bool \fBm_bGPAlpha\fP = false"
.br
.RI "GDI+ 绘图时是否启用透明度 "
.ti -1c
.RI "bool \fBm_bGPAA\fP = true"
.br
.RI "GDI+ 绘图时是否抗锯齿 "
.ti -1c
.RI "HWND \fBm_hBindWindow\fP"
.br
.RI "绑定到的窗口 "
.ti -1c
.RI "bool \fBm_bAutoMarkFlushWindow\fP = true"
.br
.RI "绑定到窗口时，标记是否在绘制后自动设置需要更新双缓冲 "
.in -1c
.SS "友元"

.in +1c
.ti -1c
.RI "void \fBBindWindowCanvas\fP (\fBCanvas\fP *, HWND)"
.br
.in -1c
.SH "详细描述"
.PP 
画布 
.PP
在文件 HiCanvas\&.h 第 117 行定义\&.
.SH "构造及析构函数说明"
.PP 
.SS "HiEasyX::Canvas::Canvas ()"

.PP
在文件 HiCanvas\&.cpp 第 301 行定义\&.
.PP
.nf
302     {
303         CleanUpSettings();
304         UpdateSizeInfo();
305     }
.fi
.SS "HiEasyX::Canvas::Canvas (int w, int h, COLORREF cBk = \fCBLACK\fP)"

.PP
在文件 HiCanvas\&.cpp 第 307 行定义\&.
.PP
.nf
308     {
309         CleanUpSettings();
310         Resize(w, h);
311         SetBkColor(cBk);
312         Clear();
313     }
.fi
.SS "HiEasyX::Canvas::Canvas (IMAGE * pImg)"

.PP
复制图像内容（绑定图像指针请调用 BindToImage） 
.PP
\fB参数\fP
.RS 4
\fIpImg\fP 原图像 
.RE
.PP

.PP
在文件 HiCanvas\&.cpp 第 315 行定义\&.
.PP
.nf
316     {
317         operator=(pImg);
318     }
.fi
.SS "HiEasyX::Canvas::Canvas (IMAGE img)"

.PP
在文件 HiCanvas\&.cpp 第 320 行定义\&.
.PP
.nf
321     {
322         operator=(img);
323     }
.fi
.SH "成员函数说明"
.PP 
.SS "void HiEasyX::Canvas::Arc (int left, int top, int right, int bottom, double stangle, double endangle, bool isSetColor = \fCfalse\fP, COLORREF c = \fC0\fP)"

.PP
在文件 HiCanvas\&.cpp 第 1012 行定义\&.
.PP
.nf
1013     {
1014         if (BeginDrawing())
1015         {
1016             if (isSetColor) setlinecolor(c);
1017             arc(left, top, right, bottom, stangle, endangle);
1018             EndDrawing();
1019         }
1020     }
.fi
.SS "void HiEasyX::Canvas::Arc (RECT rct, double stangle, double endangle, bool isSetColor = \fCfalse\fP, COLORREF c = \fC0\fP)"

.PP
在文件 HiCanvas\&.cpp 第 1022 行定义\&.
.PP
.nf
1023     {
1024         Arc(rct\&.left, rct\&.top, rct\&.right, rct\&.bottom, stangle, endangle, isSetColor, c);
1025     }
.fi
.SS "void HiEasyX::Canvas::BeginBatchDrawing ()"

.PP
.nf

    开始大批量绘制（该函数并非用于开启双缓冲）
.fi
.PP
.PP
.PP
.nf
 备注：
    调用该函数后，当前绘图目标将转移到该画布，此后每次绘制不会恢复绘图目标
.fi
.PP
 
.PP
在文件 HiCanvas\&.cpp 第 410 行定义\&.
.PP
.nf
411     {
412         if (BeginDrawing())
413         {
414             m_bBatchDraw = true;
415         }
416     }
.fi
.SS "bool HiEasyX::Canvas::BeginDrawing ()\fC [protected]\fP"

.PP
.nf

    调用 EasyX 绘图函数前，设置该画布为目标绘图画布
.fi
.PP
.PP
.PP
.nf
 备注：
    若绑定了窗口，则自动启动窗口任务
.fi
.PP
.PP
\fB返回\fP
.RS 4
是否设置成功 
.RE
.PP

.PP
在文件 HiCanvas\&.cpp 第 275 行定义\&.
.PP
.nf
276     {
277         IMAGE* p = GetImagePointer();
278         if (GetWorkingImage() != p)
279         {
280             m_property\&.SaveWorkingImageOnly();
281             SetWorkingImage(p);
282         }
283         return BeginWindowTask();
284     }
.fi
.SS "bool HiEasyX::Canvas::BeginWindowTask ()\fC [protected]\fP"

.PP
单独启动 HiWindow 的窗口任务（如果绑定了窗口） 
.PP
\fB返回\fP
.RS 4
是否启动成功 
.RE
.PP

.PP
在文件 HiCanvas\&.cpp 第 247 行定义\&.
.PP
.nf
248     {
249         if (m_hBindWindow)
250         {
251             if (HiEasyX::SetWorkingWindow(m_hBindWindow))
252             {
253                 if (HiEasyX::BeginTask())
254                 {
255                     return true;
256                 }
257             }
258             return false;
259         }
260         else
261         {
262             // 内部总是调用此函数，故未绑定窗口时直接返回 true
263             return true;
264         }
265     }
.fi
.SS "\fBCanvas\fP & HiEasyX::Canvas::BindToImage (IMAGE * pImg)"

.PP
.nf

    绑定到图像指针
.fi
.PP
.PP
.PP
.nf
 注意：
    绑定到图像指针后，如果在外部调整了图像大小，则需要调用 UpdateSizeInfo 重新加载图像信息
.fi
.PP
.PP
\fB参数\fP
.RS 4
\fIpImg\fP 目标图像指针 
.RE
.PP
\fB返回\fP
.RS 4
此画布 
.RE
.PP

.PP
在文件 HiCanvas\&.cpp 第 389 行定义\&.
.PP
.nf
390     {
391         CleanUpSettings();
392         m_bBindToImgPointer = true;
393         m_pImg = pImg;
394         UpdateSizeInfo();
395         return *this;
396     }
.fi
.SS "\fBCanvas\fP & HiEasyX::Canvas::BindToWindow (HWND hWnd, IMAGE * pImg)\fC [protected]\fP"

.PP
.nf

    将画布绑定到窗口（画布大小随窗口自动调整）
.fi
.PP
.PP
.PP
.nf
 备注：
    此函数只应该被 BindWindowCanvas 函数调用
.fi
.PP
.PP
\fB参数\fP
.RS 4
\fIhWnd\fP 目标窗口 
.br
\fIpImg\fP 窗口图像缓冲区 
.RE
.PP
\fB返回\fP
.RS 4
此画布 
.RE
.PP

.PP
在文件 HiCanvas\&.cpp 第 398 行定义\&.
.PP
.nf
399     {
400         BindToImage(pImg);
401         m_hBindWindow = hWnd;
402         return *this;
403     }
.fi
.SS "void HiEasyX::Canvas::CenterText (LPCTSTR lpszText, RECT rct = \fC{ \-1 }\fP, bool isSetColor = \fCfalse\fP, COLORREF c = \fC0\fP)"

.PP
在某区域居中输出文字 
.PP
\fB参数\fP
.RS 4
\fIlpszText\fP 文本 
.br
\fIrct\fP 输出区域，默认为画布区域 
.br
\fIisSetColor\fP 是否设置颜色 
.br
\fIc\fP 文本颜色 
.RE
.PP

.PP
在文件 HiCanvas\&.cpp 第 1277 行定义\&.
.PP
.nf
1278     {
1279         if (rct\&.left < 0)    rct = { 0,0,m_nWidth,m_nHeight };
1280         Draw_Text(lpszText, &rct, DT_CENTER | DT_VCENTER | DT_SINGLELINE, isSetColor, c);
1281     }
.fi
.SS "void HiEasyX::Canvas::CenterText_Format (int _Size, LPCTSTR _Format,  \&.\&.\&.)"

.PP
居中输出格式化文本 
.PP
\fB参数\fP
.RS 4
\fI_Size\fP 格式化文本最大长度 
.br
\fI_Format\fP 格式化字符串 
.br
\fI不定参数\fP 
.RE
.PP

.PP
在文件 HiCanvas\&.cpp 第 1283 行定义\&.
.PP
.nf
1284     {
1285         va_list list;
1286         va_start(list, _Format);
1287         wchar_t* buf = new wchar_t[_Size];
1288         vswprintf_s(buf, _Size, _Format, list);
1289         va_end(list);
1290 
1291         CenterText(buf);
1292         delete[] buf;
1293     }
.fi
.SS "void HiEasyX::Canvas::Circle (int x, int y, int radius, bool isSetColor = \fCfalse\fP, COLORREF c = \fC0\fP)"

.PP
在文件 HiCanvas\&.cpp 第 843 行定义\&.
.PP
.nf
844     {
845         if (BeginDrawing())
846         {
847             if (isSetColor) setlinecolor(c);
848             circle(x, y, radius);
849             EndDrawing();
850         }
851     }
.fi
.SS "void HiEasyX::Canvas::CleanUpSettings ()\fC [protected]\fP"

.PP
清空大部分设置 
.PP
在文件 HiCanvas\&.cpp 第 234 行定义\&.
.PP
.nf
235     {
236         m_property = {};
237         m_pBuf = nullptr;
238         m_nWidth = 0;
239         m_nHeight = 0;
240         m_nBufSize = 0;
241         m_bBindToImgPointer = false;
242         m_pImg = nullptr;
243         m_bBatchDraw = false;
244         m_hBindWindow = nullptr;
245     }
.fi
.SS "void HiEasyX::Canvas::Clear (bool isSetColor = \fCfalse\fP, COLORREF bkcolor = \fCBLACK\fP)"

.PP
.nf

    用背景色清空画布
.fi
.PP
.PP
.PP
.nf
 备注：
    此函数将忽略背景色的透明度，并直接对画布填入 255 的透明度（即不透明）。
.fi
.PP
 
.PP
在文件 HiCanvas\&.cpp 第 465 行定义\&.
.PP
.nf
466     {
467         Clear_Alpha(isSetColor, bkcolor, true);
468     }
.fi
.SS "void HiEasyX::Canvas::Clear_Alpha (bool isSetColor = \fCfalse\fP, COLORREF bkcolor = \fCBLACK\fP, bool ignore_alpha = \fCfalse\fP)"

.PP
用背景色清空画布（区别于 Clear 函数，此函数默认保留背景色中的透明度） 
.PP
在文件 HiCanvas\&.cpp 第 470 行定义\&.
.PP
.nf
471     {
472         if (BeginDrawing())
473         {
474             if (isSetColor) setbkcolor(bkcolor);
475             DWORD bk_bgr = BGR(getbkcolor());
476 
477             if (ignore_alpha)       // 设置背景透明度为 255（不透明）
478                 bk_bgr |= 0xFF000000;
479 
480             for (int i = 0; i < m_nBufSize; i++)
481                 m_pBuf[i] = bk_bgr;
482 
483             EndDrawing();
484         }
485     }
.fi
.SS "void HiEasyX::Canvas::ClearCircle (int x, int y, int radius)"

.PP
在文件 HiCanvas\&.cpp 第 877 行定义\&.
.PP
.nf
878     {
879         if (BeginDrawing())
880         {
881             clearcircle(x, y, radius);
882             EndDrawing();
883         }
884     }
.fi
.SS "void HiEasyX::Canvas::ClearEllipse (int left, int top, int right, int bottom)"

.PP
在文件 HiCanvas\&.cpp 第 935 行定义\&.
.PP
.nf
936     {
937         if (BeginDrawing())
938         {
939             clearellipse(left, top, right, bottom);
940             EndDrawing();
941         }
942     }
.fi
.SS "void HiEasyX::Canvas::ClearEllipse (RECT rct)"

.PP
在文件 HiCanvas\&.cpp 第 944 行定义\&.
.PP
.nf
945     {
946         ClearEllipse(rct\&.left, rct\&.top, rct\&.right, rct\&.bottom);
947     }
.fi
.SS "void HiEasyX::Canvas::ClearPie (int left, int top, int right, int bottom, double stangle, double endangle)"

.PP
在文件 HiCanvas\&.cpp 第 1076 行定义\&.
.PP
.nf
1077     {
1078         if (BeginDrawing())
1079         {
1080             clearpie(left, top, right, bottom, stangle, endangle);
1081             EndDrawing();
1082         }
1083     }
.fi
.SS "void HiEasyX::Canvas::ClearPie (RECT rct, double stangle, double endangle)"

.PP
在文件 HiCanvas\&.cpp 第 1085 行定义\&.
.PP
.nf
1086     {
1087         ClearPie(rct\&.left, rct\&.top, rct\&.right, rct\&.bottom, stangle, endangle);
1088     }
.fi
.SS "void HiEasyX::Canvas::ClearPolygon (const POINT * points, int num)"

.PP
在文件 HiCanvas\&.cpp 第 1134 行定义\&.
.PP
.nf
1135     {
1136         if (BeginDrawing())
1137         {
1138             clearpolygon(points, num);
1139             EndDrawing();
1140         }
1141     }
.fi
.SS "void HiEasyX::Canvas::ClearRectangle (int left, int top, int right, int bottom)"

.PP
在文件 HiCanvas\&.cpp 第 829 行定义\&.
.PP
.nf
830     {
831         if (BeginDrawing())
832         {
833             clearrectangle(left, top, right, bottom);
834             EndDrawing();
835         }
836     }
.fi
.SS "void HiEasyX::Canvas::ClearRectangle (RECT rct)"

.PP
在文件 HiCanvas\&.cpp 第 838 行定义\&.
.PP
.nf
839     {
840         ClearRectangle(rct\&.left, rct\&.top, rct\&.right, rct\&.bottom);
841     }
.fi
.SS "void HiEasyX::Canvas::ClearRoundRect (int left, int top, int right, int bottom, int ellipsewidth, int ellipseheight)"

.PP
在文件 HiCanvas\&.cpp 第 998 行定义\&.
.PP
.nf
999     {
1000         if (BeginDrawing())
1001         {
1002             clearroundrect(left, top, right, bottom, ellipsewidth, ellipseheight);
1003             EndDrawing();
1004         }
1005     }
.fi
.SS "void HiEasyX::Canvas::ClearRoundRect (RECT rct, int ellipsewidth, int ellipseheight)"

.PP
在文件 HiCanvas\&.cpp 第 1007 行定义\&.
.PP
.nf
1008     {
1009         ClearRoundRect(rct\&.left, rct\&.top, rct\&.right, rct\&.bottom, ellipsewidth, ellipseheight);
1010     }
.fi
.SS "int HiEasyX::Canvas::Draw_Text (LPCTSTR str, RECT * pRect, UINT uFormat, bool isSetColor = \fCfalse\fP, COLORREF c = \fC0\fP)"

.PP
在文件 HiCanvas\&.cpp 第 1253 行定义\&.
.PP
.nf
1254     {
1255         if (BeginDrawing())
1256         {
1257             if (isSetColor) settextcolor(c);
1258             int width = drawtext(str, pRect, uFormat);
1259             EndDrawing();
1260             return width;
1261         }
1262         return 0;
1263     }
.fi
.SS "int HiEasyX::Canvas::Draw_Text (TCHAR ch, RECT * pRect, UINT uFormat, bool isSetColor = \fCfalse\fP, COLORREF c = \fC0\fP)"

.PP
在文件 HiCanvas\&.cpp 第 1265 行定义\&.
.PP
.nf
1266     {
1267         if (BeginDrawing())
1268         {
1269             if (isSetColor) settextcolor(c);
1270             int width = drawtext(ch, pRect, uFormat);
1271             EndDrawing();
1272             return width;
1273         }
1274         return 0;
1275     }
.fi
.SS "void HiEasyX::Canvas::Ellipse (int left, int top, int right, int bottom, bool isSetColor = \fCfalse\fP, COLORREF c = \fC0\fP)"

.PP
在文件 HiCanvas\&.cpp 第 886 行定义\&.
.PP
.nf
887     {
888         if (BeginDrawing())
889         {
890             if (isSetColor) setlinecolor(c);
891             ellipse(left, top, right, bottom);
892             EndDrawing();
893         }
894     }
.fi
.SS "void HiEasyX::Canvas::Ellipse (RECT rct, bool isSetColor = \fCfalse\fP, COLORREF c = \fC0\fP)"

.PP
在文件 HiCanvas\&.cpp 第 896 行定义\&.
.PP
.nf
897     {
898         Ellipse(rct\&.left, rct\&.top, rct\&.right, rct\&.bottom, isSetColor, c);
899     }
.fi
.SS "void HiEasyX::Canvas::EnableAutoMarkFlushWindow (bool enable)"

.PP
.nf

    绑定到窗口时，设置是否在每次绘制后都自动标记刷新窗口双缓冲
.fi
.PP
.PP
.PP
.nf
 备注：
    标记刷新窗口双缓冲并不意味着即时刷新。
    标记后，窗口将会在下一次接受到绘制消息时更新双缓冲。
.fi
.PP
 
.PP
在文件 HiCanvas\&.cpp 第 405 行定义\&.
.PP
.nf
406     {
407         m_bAutoMarkFlushWindow = enable;
408     }
.fi
.SS "void HiEasyX::Canvas::EndBatchDrawing ()"

.PP
.nf

    结束批量绘制
.fi
.PP
.PP
.PP
.nf
 备注：
    绘图目标将恢复到批量绘制前的状态
.fi
.PP
 
.PP
在文件 HiCanvas\&.cpp 第 418 行定义\&.
.PP
.nf
419     {
420         if (m_bBatchDraw)
421         {
422             m_bBatchDraw = false;
423             EndDrawing();
424         }
425     }
.fi
.SS "void HiEasyX::Canvas::EndDrawing ()\fC [protected]\fP"

.PP
调用 EasyX 绘图函数完毕，恢复先前的绘图状态 
.PP
在文件 HiCanvas\&.cpp 第 286 行定义\&.
.PP
.nf
287     {
288         // 批量绘制模式下，不退出绘图目标
289         if (!m_bBatchDraw)
290         {
291             if (m_property\&.IsSaved())
292             {
293                 m_property\&.ApplyWorkingImageOnly();
294                 m_property\&.Reset();
295             }
296 
297             EndWindowTask();
298         }
299     }
.fi
.SS "void HiEasyX::Canvas::EndWindowTask ()\fC [protected]\fP"

.PP
结束 HiWindow 的窗口任务 
.PP
在文件 HiCanvas\&.cpp 第 267 行定义\&.
.PP
.nf
268     {
269         if (m_hBindWindow)
270         {
271             HiEasyX::EndTask(m_bAutoMarkFlushWindow);
272         }
273     }
.fi
.SS "void HiEasyX::Canvas::FillCircle (int x, int y, int radius, bool isSetColor = \fCfalse\fP, COLORREF cLine = \fC0\fP, COLORREF cFill = \fC0\fP)"

.PP
在文件 HiCanvas\&.cpp 第 853 行定义\&.
.PP
.nf
854     {
855         if (BeginDrawing())
856         {
857             if (isSetColor)
858             {
859                 setlinecolor(cLine);
860                 setfillcolor(cFill);
861             }
862             fillcircle(x, y, radius);
863             EndDrawing();
864         }
865     }
.fi
.SS "void HiEasyX::Canvas::FillEllipse (int left, int top, int right, int bottom, bool isSetColor = \fCfalse\fP, COLORREF cLine = \fC0\fP, COLORREF cFill = \fC0\fP)"

.PP
在文件 HiCanvas\&.cpp 第 901 行定义\&.
.PP
.nf
902     {
903         if (BeginDrawing())
904         {
905             if (isSetColor)
906             {
907                 setlinecolor(cLine);
908                 setfillcolor(cFill);
909             }
910             fillellipse(left, top, right, bottom);
911             EndDrawing();
912         }
913     }
.fi
.SS "void HiEasyX::Canvas::FillEllipse (RECT rct, bool isSetColor = \fCfalse\fP, COLORREF cLine = \fC0\fP, COLORREF cFill = \fC0\fP)"

.PP
在文件 HiCanvas\&.cpp 第 915 行定义\&.
.PP
.nf
916     {
917         FillEllipse(rct\&.left, rct\&.top, rct\&.right, rct\&.bottom, isSetColor, cLine, cFill);
918     }
.fi
.SS "void HiEasyX::Canvas::FillPie (int left, int top, int right, int bottom, double stangle, double endangle, bool isSetColor = \fCfalse\fP, COLORREF cLine = \fC0\fP, COLORREF cFill = \fC0\fP)"

.PP
在文件 HiCanvas\&.cpp 第 1042 行定义\&.
.PP
.nf
1043     {
1044         if (BeginDrawing())
1045         {
1046             if (isSetColor)
1047             {
1048                 setlinecolor(cLine);
1049                 setfillcolor(cFill);
1050             }
1051             fillpie(left, top, right, bottom, stangle, endangle);
1052             EndDrawing();
1053         }
1054     }
.fi
.SS "void HiEasyX::Canvas::FillPie (RECT rct, double stangle, double endangle, bool isSetColor = \fCfalse\fP, COLORREF cLine = \fC0\fP, COLORREF cFill = \fC0\fP)"

.PP
在文件 HiCanvas\&.cpp 第 1056 行定义\&.
.PP
.nf
1057     {
1058         FillPie(rct\&.left, rct\&.top, rct\&.right, rct\&.bottom, stangle, endangle, isSetColor, cLine, cFill);
1059     }
.fi
.SS "void HiEasyX::Canvas::FillPolygon (const POINT * points, int num, bool isSetColor = \fCfalse\fP, COLORREF cLine = \fC0\fP, COLORREF cFill = \fC0\fP)"

.PP
在文件 HiCanvas\&.cpp 第 1110 行定义\&.
.PP
.nf
1111     {
1112         if (BeginDrawing())
1113         {
1114             if (isSetColor)
1115             {
1116                 setlinecolor(cLine);
1117                 setfillcolor(cFill);
1118             }
1119             fillpolygon(points, num);
1120             EndDrawing();
1121         }
1122     }
.fi
.SS "void HiEasyX::Canvas::FillRectangle (int left, int top, int right, int bottom, bool isSetColor = \fCfalse\fP, COLORREF cLine = \fC0\fP, COLORREF cFill = \fC0\fP)"

.PP
在文件 HiCanvas\&.cpp 第 794 行定义\&.
.PP
.nf
795     {
796         if (BeginDrawing())
797         {
798             if (isSetColor)
799             {
800                 setlinecolor(cLine);
801                 setfillcolor(cFill);
802             }
803 
804             fillrectangle(left, top, right, bottom);
805             EndDrawing();
806         }
807     }
.fi
.SS "void HiEasyX::Canvas::FillRectangle (RECT rct, bool isSetColor = \fCfalse\fP, COLORREF cLine = \fC0\fP, COLORREF cFill = \fC0\fP)"

.PP
在文件 HiCanvas\&.cpp 第 809 行定义\&.
.PP
.nf
810     {
811         FillRectangle(rct\&.left, rct\&.top, rct\&.right, rct\&.bottom, isSetColor, cLine, cFill);
812     }
.fi
.SS "void HiEasyX::Canvas::FillRoundRect (int left, int top, int right, int bottom, int ellipsewidth, int ellipseheight, bool isSetColor = \fCfalse\fP, COLORREF cLine = \fC0\fP, COLORREF cFill = \fC0\fP)"

.PP
在文件 HiCanvas\&.cpp 第 964 行定义\&.
.PP
.nf
965     {
966         if (BeginDrawing())
967         {
968             if (isSetColor)
969             {
970                 setlinecolor(cLine);
971                 setfillcolor(cFill);
972             }
973             fillroundrect(left, top, right, bottom, ellipsewidth, ellipseheight);
974             EndDrawing();
975         }
976     }
.fi
.SS "void HiEasyX::Canvas::FillRoundRect (RECT rct, int ellipsewidth, int ellipseheight, bool isSetColor = \fCfalse\fP, COLORREF cLine = \fC0\fP, COLORREF cFill = \fC0\fP)"

.PP
在文件 HiCanvas\&.cpp 第 978 行定义\&.
.PP
.nf
979     {
980         FillRoundRect(rct\&.left, rct\&.top, rct\&.right, rct\&.bottom, ellipsewidth, ellipseheight, cLine, cFill, isSetColor);
981     }
.fi
.SS "void HiEasyX::Canvas::FloodFill (int x, int y, COLORREF color, int filltype = \fCFLOODFILLBORDER\fP, bool isSetColor = \fCfalse\fP, COLORREF cFill = \fC0\fP)"

.PP
填充某区域 
.PP
\fB参数\fP
.RS 4
\fIx\fP 填充起始位置 
.br
\fIy\fP 填充起始位置 
.br
\fIcolor\fP 填充颜色
.br
\fIfilltype\fP 
.PP
.nf

    填充模式，有以下两种选择：
    FLOODFILLBORDER     指定 color 为填充边界颜色，即遇到此颜色后停止填充
    FLOODFILLSURFACE    指定 color 为填充表面颜色，即只填充此颜色
.fi
.PP
.br
\fIisSetColor\fP 是否设置填充颜色 
.br
\fIcFill\fP 填充颜色 
.RE
.PP

.PP
在文件 HiCanvas\&.cpp 第 1153 行定义\&.
.PP
.nf
1154     {
1155         if (BeginDrawing())
1156         {
1157             if (isSetColor) setfillcolor(cFill);
1158             floodfill(x, y, color, filltype);
1159             EndDrawing();
1160         }
1161     }
.fi
.SS "COLORREF HiEasyX::Canvas::GetBkColor ()"

.PP
在文件 HiCanvas\&.cpp 第 665 行定义\&.
.PP
.nf
666     {
667         if (BeginDrawing())
668         {
669             COLORREF r = getbkcolor();
670             EndDrawing();
671             return r;
672         }
673         return 0;
674     }
.fi
.SS "int HiEasyX::Canvas::GetBkMode ()"

.PP
在文件 HiCanvas\&.cpp 第 685 行定义\&.
.PP
.nf
686     {
687         if (BeginDrawing())
688         {
689             COLORREF r = getbkmode();
690             EndDrawing();
691             return r;
692         }
693         return 0;
694     }
.fi
.SS "DWORD* HiEasyX::Canvas::GetBuffer () const\fC [inline]\fP"

.PP
获取图像缓冲区指针 
.PP
在文件 HiCanvas\&.h 第 267 行定义\&.
.PP
.nf
267 { return m_pBuf; }
.fi
.SS "int HiEasyX::Canvas::GetBufferSize () const\fC [inline]\fP"

.PP
获取图像缓冲区大小，即图像面积（宽 * 高） 
.PP
在文件 HiCanvas\&.h 第 272 行定义\&.
.PP
.nf
272 { return m_nBufSize; }
.fi
.SS "COLORREF HiEasyX::Canvas::GetColor ()"

.PP
获取前景色 
.PP
在文件 HiCanvas\&.cpp 第 1440 行定义\&.
.PP
.nf
1441     {
1442         if (BeginDrawing())
1443         {
1444             int r = getcolor();
1445             EndDrawing();
1446             return r;
1447         }
1448         return 0;
1449     }
.fi
.SS "COLORREF HiEasyX::Canvas::GetFillColor ()"

.PP
在文件 HiCanvas\&.cpp 第 645 行定义\&.
.PP
.nf
646     {
647         if (BeginDrawing())
648         {
649             COLORREF r = getfillcolor();
650             EndDrawing();
651             return r;
652         }
653         return 0;
654     }
.fi
.SS "FILLSTYLE HiEasyX::Canvas::GetFillStyle ()"

.PP
在文件 HiCanvas\&.cpp 第 517 行定义\&.
.PP
.nf
518     {
519         if (BeginDrawing())
520         {
521             FILLSTYLE s;
522             getfillstyle(&s);
523             EndDrawing();
524             return s;
525         }
526         return {};
527     }
.fi
.SS "HDC HiEasyX::Canvas::GetHDC ()\fC [inline]\fP"

.PP
获取画布的 HDC 
.PP
在文件 HiCanvas\&.h 第 277 行定义\&.
.PP
.nf
277 { return GetImageHDC(GetImagePointer()); }
.fi
.SS "int HiEasyX::Canvas::getheight () const\fC [inline]\fP"

.PP
在文件 HiCanvas\&.h 第 280 行定义\&.
.PP
.nf
280 { return m_nHeight; }
.fi
.SS "int HiEasyX::Canvas::GetHeight () const\fC [inline]\fP"

.PP
在文件 HiCanvas\&.h 第 282 行定义\&.
.PP
.nf
282 { return m_nHeight; }
.fi
.SS "IMAGE* HiEasyX::Canvas::GetImagePointer ()\fC [inline]\fP"

.PP
.nf

    获取画布 IMAGE 指针
.fi
.PP
.PP
.PP
.nf
 注意：
    有的时候画布绑定了别的 IMAGE，所以绘图时不能直接使用 this，必须调用此函数。
.fi
.PP
 
.PP
在文件 HiCanvas\&.h 第 257 行定义\&.
.PP
.nf
257 { return m_bBindToImgPointer ? m_pImg : this; }
.fi
.SS "COLORREF HiEasyX::Canvas::GetLineColor ()"

.PP
在文件 HiCanvas\&.cpp 第 605 行定义\&.
.PP
.nf
606     {
607         if (BeginDrawing())
608         {
609             COLORREF r = getlinecolor();
610             EndDrawing();
611             return r;
612         }
613         return 0;
614     }
.fi
.SS "LINESTYLE HiEasyX::Canvas::GetLineStyle ()"

.PP
在文件 HiCanvas\&.cpp 第 453 行定义\&.
.PP
.nf
454     {
455         if (BeginDrawing())
456         {
457             LINESTYLE s;
458             getlinestyle(&s);
459             EndDrawing();
460             return s;
461         }
462         return {};
463     }
.fi
.SS "int HiEasyX::Canvas::GetLineThickness ()"

.PP
在文件 HiCanvas\&.cpp 第 512 行定义\&.
.PP
.nf
513     {
514         return GetLineStyle()\&.thickness;
515     }
.fi
.SS "COLORREF HiEasyX::Canvas::GetPixel (int x, int y)"

.PP
在文件 HiCanvas\&.cpp 第 705 行定义\&.
.PP
.nf
706     {
707         if (BeginDrawing())
708         {
709             COLORREF c = getpixel(x, y);
710             EndDrawing();
711             return c;
712         }
713         return 0;
714     }
.fi
.SS "COLORREF HiEasyX::Canvas::GetPixel_Direct (int x, int y)"

.PP
直接操作显存获取点 
.PP
在文件 HiCanvas\&.cpp 第 725 行定义\&.
.PP
.nf
726     {
727         if (BeginWindowTask())
728         {
729             COLORREF c = BGR(m_pBuf[y * m_nWidth + x]);
730             EndWindowTask();
731             return c;
732         }
733         return 0;
734     }
.fi
.SS "int HiEasyX::Canvas::GetPolyFillMode ()"

.PP
在文件 HiCanvas\&.cpp 第 576 行定义\&.
.PP
.nf
577     {
578         if (BeginDrawing())
579         {
580             int r = getpolyfillmode();
581             EndDrawing();
582             return r;
583         }
584         return 0;
585     }
.fi
.SS "int HiEasyX::Canvas::GetRop2 ()"

.PP
在文件 HiCanvas\&.cpp 第 556 行定义\&.
.PP
.nf
557     {
558         if (BeginDrawing())
559         {
560             int r = getrop2();
561             EndDrawing();
562             return r;
563         }
564         return 0;
565     }
.fi
.SS "COLORREF HiEasyX::Canvas::GetTextColor ()"

.PP
在文件 HiCanvas\&.cpp 第 625 行定义\&.
.PP
.nf
626     {
627         if (BeginDrawing())
628         {
629             COLORREF r = gettextcolor();
630             EndDrawing();
631             return r;
632         }
633         return 0;
634     }
.fi
.SS "LOGFONT HiEasyX::Canvas::GetTextStyle ()"

.PP
在文件 HiCanvas\&.cpp 第 1295 行定义\&.
.PP
.nf
1296     {
1297         if (BeginDrawing())
1298         {
1299             LOGFONT font;
1300             gettextstyle(&font);
1301             EndDrawing();
1302             return font;
1303         }
1304         return {};
1305     }
.fi
.SS "int HiEasyX::Canvas::getwidth () const\fC [inline]\fP"

.PP
在文件 HiCanvas\&.h 第 279 行定义\&.
.PP
.nf
279 { return m_nWidth; }
.fi
.SS "int HiEasyX::Canvas::GetWidth () const\fC [inline]\fP"

.PP
在文件 HiCanvas\&.h 第 281 行定义\&.
.PP
.nf
281 { return m_nWidth; }
.fi
.SS "int HiEasyX::Canvas::GetX ()"

.PP
在文件 HiCanvas\&.cpp 第 1460 行定义\&.
.PP
.nf
1461     {
1462         if (BeginDrawing())
1463         {
1464             int r = getx();
1465             EndDrawing();
1466             return r;
1467         }
1468         return 0;
1469     }
.fi
.SS "int HiEasyX::Canvas::GetY ()"

.PP
在文件 HiCanvas\&.cpp 第 1471 行定义\&.
.PP
.nf
1472     {
1473         if (BeginDrawing())
1474         {
1475             int r = gety();
1476             EndDrawing();
1477             return r;
1478         }
1479         return 0;
1480     }
.fi
.SS "void HiEasyX::Canvas::GP_Arc (float x, float y, float w, float h, float stangle, float endangle, bool isSetColor = \fCfalse\fP, COLORREF linecolor = \fC0\fP)"

.PP
在文件 HiCanvas\&.cpp 第 1833 行定义\&.
.PP
.nf
1834     {
1835         if (BeginWindowTask())
1836         {
1837             if (isSetColor) GP_SetLineColor(linecolor);
1838             EasyX_Gdiplus_Arc(x, y, w, h, stangle, endangle, m_cGPLineColor, m_fGPLineWidth, m_bGPAlpha, m_bGPAA, Pt());
1839             EndWindowTask();
1840         }
1841     }
.fi
.SS "void HiEasyX::Canvas::GP_Ellipse (float x, float y, float w, float h, bool isSetColor = \fCfalse\fP, COLORREF linecolor = \fC0\fP)"

.PP
在文件 HiCanvas\&.cpp 第 1765 行定义\&.
.PP
.nf
1766     {
1767         if (BeginWindowTask())
1768         {
1769             if (isSetColor) GP_SetLineColor(linecolor);
1770             EasyX_Gdiplus_Ellipse(x, y, w, h, m_cGPLineColor, m_fGPLineWidth, m_bGPAlpha, m_bGPAA, Pt());
1771             EndWindowTask();
1772         }
1773     }
.fi
.SS "void HiEasyX::Canvas::GP_EnableAA (bool enable)"

.PP
设置 GDI+ 绘制时是否抗锯齿 
.PP
在文件 HiCanvas\&.cpp 第 1682 行定义\&.
.PP
.nf
1683     {
1684         m_bGPAA = enable;
1685     }
.fi
.SS "void HiEasyX::Canvas::GP_EnableAlpha (bool enable)"

.PP
设置 GDI+ 绘制时是否使用透明度 
.PP
在文件 HiCanvas\&.cpp 第 1677 行定义\&.
.PP
.nf
1678     {
1679         m_bGPAlpha = enable;
1680     }
.fi
.SS "void HiEasyX::Canvas::GP_FillEllipse (float x, float y, float w, float h, bool isSetColor = \fCfalse\fP, COLORREF linecolor = \fC0\fP, COLORREF fillcolor = \fC0\fP)"

.PP
在文件 HiCanvas\&.cpp 第 1785 行定义\&.
.PP
.nf
1786     {
1787         if (BeginWindowTask())
1788         {
1789             if (isSetColor)
1790             {
1791                 GP_SetLineColor(linecolor);
1792                 GP_SetFillColor(fillcolor);
1793             }
1794             EasyX_Gdiplus_FillEllipse(x, y, w, h, m_cGPLineColor, m_cGPFillColor, m_fGPLineWidth, m_bGPAlpha, m_bGPAA, Pt());
1795             EndWindowTask();
1796         }
1797     }
.fi
.SS "void HiEasyX::Canvas::GP_FillPie (float x, float y, float w, float h, float stangle, float endangle, bool isSetColor = \fCfalse\fP, COLORREF linecolor = \fC0\fP, COLORREF fillcolor = \fC0\fP)"

.PP
在文件 HiCanvas\&.cpp 第 1819 行定义\&.
.PP
.nf
1820     {
1821         if (BeginWindowTask())
1822         {
1823             if (isSetColor)
1824             {
1825                 GP_SetLineColor(linecolor);
1826                 GP_SetFillColor(fillcolor);
1827             }
1828             EasyX_Gdiplus_FillPie(x, y, w, h, stangle, endangle, m_cGPLineColor, m_cGPFillColor, m_fGPLineWidth, m_bGPAlpha, m_bGPAA, Pt());
1829             EndWindowTask();
1830         }
1831     }
.fi
.SS "void HiEasyX::Canvas::GP_FillPolygon (int points_num, POINT * points, bool isSetColor = \fCfalse\fP, COLORREF linecolor = \fC0\fP, COLORREF fillcolor = \fC0\fP)"

.PP
在文件 HiCanvas\&.cpp 第 1717 行定义\&.
.PP
.nf
1718     {
1719         if (BeginWindowTask())
1720         {
1721             if (isSetColor)
1722             {
1723                 GP_SetLineColor(linecolor);
1724                 GP_SetFillColor(fillcolor);
1725             }
1726             EasyX_Gdiplus_FillPolygon(points_num, points, m_cGPLineColor, m_cGPFillColor, m_fGPLineWidth, m_bGPAlpha, m_bGPAA, Pt());
1727             EndWindowTask();
1728         }
1729     }
.fi
.SS "void HiEasyX::Canvas::GP_FillRectangle (float x, float y, float w, float h, bool isSetColor = \fCfalse\fP, COLORREF linecolor = \fC0\fP, COLORREF fillcolor = \fC0\fP)"

.PP
在文件 HiCanvas\&.cpp 第 1751 行定义\&.
.PP
.nf
1752     {
1753         if (BeginWindowTask())
1754         {
1755             if (isSetColor)
1756             {
1757                 GP_SetLineColor(linecolor);
1758                 GP_SetFillColor(fillcolor);
1759             }
1760             EasyX_Gdiplus_FillRectangle(x, y, w, h, m_cGPLineColor, m_cGPFillColor, m_fGPLineWidth, m_bGPAlpha, m_bGPAA, Pt());
1761             EndWindowTask();
1762         }
1763     }
.fi
.SS "COLORREF HiEasyX::Canvas::GP_GetFillColor () const\fC [inline]\fP"

.PP
在文件 HiCanvas\&.h 第 731 行定义\&.
.PP
.nf
731 { return m_cGPFillColor; }
.fi
.SS "COLORREF HiEasyX::Canvas::GP_GetLineColor () const\fC [inline]\fP"

.PP
在文件 HiCanvas\&.h 第 730 行定义\&.
.PP
.nf
730 { return m_cGPLineColor; }
.fi
.SS "float HiEasyX::Canvas::GP_GetLineWidth () const\fC [inline]\fP"

.PP
在文件 HiCanvas\&.h 第 732 行定义\&.
.PP
.nf
732 { return m_fGPLineWidth; }
.fi
.SS "bool HiEasyX::Canvas::GP_IsEnbaleAA () const\fC [inline]\fP"

.PP
在文件 HiCanvas\&.h 第 745 行定义\&.
.PP
.nf
745 { return m_bGPAA; }
.fi
.SS "bool HiEasyX::Canvas::GP_IsEnbaleAlpha () const\fC [inline]\fP"

.PP
在文件 HiCanvas\&.h 第 744 行定义\&.
.PP
.nf
744 { return m_bGPAlpha; }
.fi
.SS "void HiEasyX::Canvas::GP_Line (float x1, float y1, float x2, float y2, bool isSetColor = \fCfalse\fP, COLORREF linecolor = \fC0\fP)"

.PP
在文件 HiCanvas\&.cpp 第 1687 行定义\&.
.PP
.nf
1688     {
1689         if (BeginWindowTask())
1690         {
1691             if (isSetColor) GP_SetLineColor(linecolor);
1692             EasyX_Gdiplus_Line(x1, y1, x2, y2, m_cGPLineColor, m_fGPLineWidth, m_bGPAlpha, m_bGPAA, Pt());
1693             EndWindowTask();
1694         }
1695     }
.fi
.SS "void HiEasyX::Canvas::GP_Pie (float x, float y, float w, float h, float stangle, float endangle, bool isSetColor = \fCfalse\fP, COLORREF linecolor = \fC0\fP)"

.PP
在文件 HiCanvas\&.cpp 第 1799 行定义\&.
.PP
.nf
1800     {
1801         if (BeginWindowTask())
1802         {
1803             if (isSetColor) GP_SetLineColor(linecolor);
1804             EasyX_Gdiplus_Pie(x, y, w, h, stangle, endangle, m_cGPLineColor, m_fGPLineWidth, m_bGPAlpha, m_bGPAA, Pt());
1805             EndWindowTask();
1806         }
1807     }
.fi
.SS "void HiEasyX::Canvas::GP_Polygon (int points_num, POINT * points, bool isSetColor = \fCfalse\fP, COLORREF linecolor = \fC0\fP)"

.PP
在文件 HiCanvas\&.cpp 第 1697 行定义\&.
.PP
.nf
1698     {
1699         if (BeginWindowTask())
1700         {
1701             if (isSetColor) GP_SetLineColor(linecolor);
1702             EasyX_Gdiplus_Polygon(points_num, points, m_cGPLineColor, m_fGPLineWidth, m_bGPAlpha, m_bGPAA, Pt());
1703             EndWindowTask();
1704         }
1705     }
.fi
.SS "void HiEasyX::Canvas::GP_Rectangle (float x, float y, float w, float h, bool isSetColor = \fCfalse\fP, COLORREF linecolor = \fC0\fP)"

.PP
在文件 HiCanvas\&.cpp 第 1731 行定义\&.
.PP
.nf
1732     {
1733         if (BeginWindowTask())
1734         {
1735             if (isSetColor) GP_SetLineColor(linecolor);
1736             EasyX_Gdiplus_Rectangle(x, y, w, h, m_cGPLineColor, m_fGPLineWidth, m_bGPAlpha, m_bGPAA, Pt());
1737             EndWindowTask();
1738         }
1739     }
.fi
.SS "void HiEasyX::Canvas::GP_SetFillColor (COLORREF color)"

.PP
在文件 HiCanvas\&.cpp 第 1667 行定义\&.
.PP
.nf
1668     {
1669         m_cGPFillColor = color;
1670     }
.fi
.SS "void HiEasyX::Canvas::GP_SetLineColor (COLORREF color)"

.PP
在文件 HiCanvas\&.cpp 第 1662 行定义\&.
.PP
.nf
1663     {
1664         m_cGPLineColor = color;
1665     }
.fi
.SS "void HiEasyX::Canvas::GP_SetLineWidth (float width)"

.PP
在文件 HiCanvas\&.cpp 第 1672 行定义\&.
.PP
.nf
1673     {
1674         m_fGPLineWidth = width;
1675     }
.fi
.SS "void HiEasyX::Canvas::GP_SolidEllipse (float x, float y, float w, float h, bool isSetColor = \fCfalse\fP, COLORREF fillcolor = \fC0\fP)"

.PP
在文件 HiCanvas\&.cpp 第 1775 行定义\&.
.PP
.nf
1776     {
1777         if (BeginWindowTask())
1778         {
1779             if (isSetColor) GP_SetFillColor(fillcolor);
1780             EasyX_Gdiplus_SolidEllipse(x, y, w, h, m_cGPFillColor, m_bGPAlpha, m_bGPAA, Pt());
1781             EndWindowTask();
1782         }
1783     }
.fi
.SS "void HiEasyX::Canvas::GP_SolidPie (float x, float y, float w, float h, float stangle, float endangle, bool isSetColor = \fCfalse\fP, COLORREF fillcolor = \fC0\fP)"

.PP
在文件 HiCanvas\&.cpp 第 1809 行定义\&.
.PP
.nf
1810     {
1811         if (BeginWindowTask())
1812         {
1813             if (isSetColor) GP_SetFillColor(fillcolor);
1814             EasyX_Gdiplus_SolidPie(x, y, w, h, stangle, endangle, m_cGPFillColor, m_bGPAlpha, m_bGPAA, Pt());
1815             EndWindowTask();
1816         }
1817     }
.fi
.SS "void HiEasyX::Canvas::GP_SolidPolygon (int points_num, POINT * points, bool isSetColor = \fCfalse\fP, COLORREF fillcolor = \fC0\fP)"

.PP
在文件 HiCanvas\&.cpp 第 1707 行定义\&.
.PP
.nf
1708     {
1709         if (BeginWindowTask())
1710         {
1711             if (isSetColor) GP_SetFillColor(fillcolor);
1712             EasyX_Gdiplus_SolidPolygon(points_num, points, m_cGPFillColor, m_bGPAlpha, m_bGPAA, Pt());
1713             EndWindowTask();
1714         }
1715     }
.fi
.SS "void HiEasyX::Canvas::GP_SolidRectangle (float x, float y, float w, float h, bool isSetColor = \fCfalse\fP, COLORREF fillcolor = \fC0\fP)"

.PP
在文件 HiCanvas\&.cpp 第 1741 行定义\&.
.PP
.nf
1742     {
1743         if (BeginWindowTask())
1744         {
1745             if (isSetColor) GP_SetFillColor(fillcolor);
1746             EasyX_Gdiplus_SolidRectangle(x, y, w, h, m_cGPFillColor, m_bGPAlpha, m_bGPAA, Pt());
1747             EndWindowTask();
1748         }
1749     }
.fi
.SS "bool HiEasyX::Canvas::IsEnableAutoMarkFlushWindow () const\fC [inline]\fP"

.PP
在文件 HiCanvas\&.h 第 294 行定义\&.
.PP
.nf
294 { return m_bAutoMarkFlushWindow; }
.fi
.SS "bool HiEasyX::Canvas::IsValidPoint (int x, int y, int * pIndex = \fCnullptr\fP)"

.PP
判断某点是否位于图像中 
.PP
\fB参数\fP
.RS 4
\fIx\fP 坐标 
.br
\fIy\fP 坐标 
.br
\fIpIndex\fP 返回该点数组索引 
.RE
.PP
\fB返回\fP
.RS 4
是否位于图像中 
.RE
.PP

.PP
在文件 HiCanvas\&.cpp 第 427 行定义\&.
.PP
.nf
428     {
429         if (x < 0 || y < 0 || x >= m_nWidth || y >= m_nHeight)
430             return false;
431         if (pIndex) *pIndex = y * m_nWidth + x;
432         return true;
433     }
.fi
.SS "void HiEasyX::Canvas::Line (int x1, int y1, int x2, int y2, bool isSetColor = \fCfalse\fP, COLORREF c = \fC0\fP)"

.PP
在文件 HiCanvas\&.cpp 第 764 行定义\&.
.PP
.nf
765     {
766         if (BeginDrawing())
767         {
768             if (isSetColor) setlinecolor(c);
769             line(x1, y1, x2, y2);
770             EndDrawing();
771         }
772     }
.fi
.SS "void HiEasyX::Canvas::Line (POINT pt1, POINT pt2, bool isSetColor = \fCfalse\fP, COLORREF c = \fC0\fP)"

.PP
在文件 HiCanvas\&.cpp 第 774 行定义\&.
.PP
.nf
775     {
776         Line(pt1\&.x, pt1\&.y, pt2\&.x, pt2\&.y, isSetColor, c);
777     }
.fi
.SS "void HiEasyX::Canvas::LineRel (int dx, int dy, bool isSetColor = \fCfalse\fP, COLORREF c = \fC0\fP)"

.PP
在文件 HiCanvas\&.cpp 第 1510 行定义\&.
.PP
.nf
1511     {
1512         if (BeginDrawing())
1513         {
1514             if (isSetColor) setcolor(c);
1515             linerel(dx, dy);
1516             EndDrawing();
1517         }
1518     }
.fi
.SS "void HiEasyX::Canvas::LineTo (int x, int y, bool isSetColor = \fCfalse\fP, COLORREF c = \fC0\fP)"

.PP
在文件 HiCanvas\&.cpp 第 1500 行定义\&.
.PP
.nf
1501     {
1502         if (BeginDrawing())
1503         {
1504             if (isSetColor) setcolor(c);
1505             lineto(x, y);
1506             EndDrawing();
1507         }
1508     }
.fi
.SS "IMAGE HiEasyX::Canvas::Load_Image_Alpha (LPCTSTR lpszImgFile, int x = \fC0\fP, int y = \fC0\fP, bool bResize = \fCtrue\fP, int nWidth = \fC0\fP, int nHeight = \fC0\fP, BYTE alpha = \fC255\fP, bool bUseSrcAlpha = \fCfalse\fP)"

.PP
.nf

    加载图片文件到画布
.fi
.PP
.PP
.PP
.nf
 备注：
    若开启透明通道，则复制到画布上的内容不会保留原图像的透明度信息
.fi
.PP
.PP
\fB参数\fP
.RS 4
\fIlpszImgFile\fP 图像文件路径 
.br
\fIx\fP 输出到画布的位置 
.br
\fIy\fP 输出到画布的位置 
.br
\fIbResize\fP 是否调整画布大小以正好容纳图像 
.br
\fInWidth\fP 图像目标拉伸尺寸，为 0 表示不拉伸 
.br
\fInHeight\fP 图像目标拉伸尺寸，为 0 表示不拉伸 
.br
\fIalpha\fP 叠加透明度 
.br
\fIbUseSrcAlpha\fP 是否使用原图的透明度信息进行混合（仅支持有透明度信息的 png 图像） 
.RE
.PP
\fB返回\fP
.RS 4
读取到的 IMAGE 对象 
.RE
.PP

.PP
在文件 HiCanvas\&.cpp 第 1560 行定义\&.
.PP
.nf
1561     {
1562         if (!bResize && (x > m_nWidth || y > m_nHeight))    return {};
1563         IMAGE img;
1564         loadimage(&img, lpszImgFile, nWidth, nHeight, true);
1565         int w = img\&.getwidth(), h = img\&.getheight();
1566         if (x <= -w || y <= -h) return {};
1567         if (bResize)
1568         {
1569             int nw = x + w;
1570             int nh = y + h;
1571             Resize(m_nWidth < nw ? nw : m_nWidth, m_nHeight < nh ? nh : m_nHeight);
1572         }
1573         PutImageIn_Alpha(x, y, &img, { 0 }, alpha, bUseSrcAlpha);
1574         return img;
1575     }
.fi
.SS "void HiEasyX::Canvas::MoveRel (int dx, int dy)"

.PP
在文件 HiCanvas\&.cpp 第 1491 行定义\&.
.PP
.nf
1492     {
1493         if (BeginDrawing())
1494         {
1495             moverel(dx, dy);
1496             EndDrawing();
1497         }
1498     }
.fi
.SS "void HiEasyX::Canvas::MoveTo (int x, int y)"

.PP
在文件 HiCanvas\&.cpp 第 1482 行定义\&.
.PP
.nf
1483     {
1484         if (BeginDrawing())
1485         {
1486             moveto(x, y);
1487             EndDrawing();
1488         }
1489     }
.fi
.SS "\fBCanvas\fP & HiEasyX::Canvas::operator= (IMAGE * pImg)"

.PP
复制图像内容（绑定图像指针请调用 BindToImage） 
.PP
\fB参数\fP
.RS 4
\fIpImg\fP 原图像 
.RE
.PP

.PP
在文件 HiCanvas\&.cpp 第 325 行定义\&.
.PP
.nf
326     {
327         CleanUpSettings();
328         int w, h;
329         GetImageSize(pImg, &w, &h);
330 
331         if (BeginWindowTask())
332         {
333             Resize(w, h);
334             UpdateSizeInfo();
335 
336             // 不使用 IMAGE::operator=，因为它不支持指针
337             memcpy(m_pBuf, GetImageBuffer(pImg), m_nBufSize * sizeof(COLORREF));
338             EndWindowTask();
339         }
340 
341         return *this;
342     }
.fi
.SS "\fBCanvas\fP & HiEasyX::Canvas::operator= (IMAGE img)"

.PP
在文件 HiCanvas\&.cpp 第 344 行定义\&.
.PP
.nf
345     {
346         return operator=(&img);
347     }
.fi
.SS "void HiEasyX::Canvas::OutText (LPCTSTR lpszText, bool isSetColor = \fCfalse\fP, COLORREF c = \fC0\fP)"

.PP
在文件 HiCanvas\&.cpp 第 1520 行定义\&.
.PP
.nf
1521     {
1522         if (BeginDrawing())
1523         {
1524             if (isSetColor) setcolor(c);
1525             outtext(lpszText);
1526             EndDrawing();
1527         }
1528     }
.fi
.SS "void HiEasyX::Canvas::OutText (TCHAR ch, bool isSetColor = \fCfalse\fP, COLORREF c = \fC0\fP)"

.PP
在文件 HiCanvas\&.cpp 第 1530 行定义\&.
.PP
.nf
1531     {
1532         if (BeginDrawing())
1533         {
1534             if (isSetColor) setcolor(c);
1535             outtext(ch);
1536             EndDrawing();
1537         }
1538     }
.fi
.SS "int HiEasyX::Canvas::OutText_Format (int _Size, LPCTSTR _Format,  \&.\&.\&.)"

.PP
输出格式化文本 
.PP
\fB参数\fP
.RS 4
\fI_Size\fP 格式化文本最大长度 
.br
\fI_Format\fP 格式化字符串 
.br
\fI不定参数\fP 
.RE
.PP
\fB返回\fP
.RS 4
文本像素宽度 
.RE
.PP

.PP
在文件 HiCanvas\&.cpp 第 1540 行定义\&.
.PP
.nf
1541     {
1542         if (BeginDrawing())
1543         {
1544             va_list list;
1545             va_start(list, _Format);
1546             wchar_t* buf = new wchar_t[_Size];
1547             vswprintf_s(buf, _Size, _Format, list);
1548             va_end(list);
1549 
1550             outtext(buf);
1551             int width = textwidth(buf);
1552             delete[] buf;
1553 
1554             EndDrawing();
1555             return width;
1556         }
1557         return 0;
1558     }
.fi
.SS "int HiEasyX::Canvas::OutTextXY (int x, int y, LPCTSTR lpszText, bool isSetColor = \fCfalse\fP, COLORREF c = \fC0\fP)"

.PP
在指定位置输出文本 
.PP
\fB参数\fP
.RS 4
\fIx\fP 位置 
.br
\fIy\fP 位置 
.br
\fIlpszText\fP 文本 
.br
\fIisSetColor\fP 是否设置颜色 
.br
\fIc\fP 文本颜色 
.RE
.PP
\fB返回\fP
.RS 4
文本像素宽度 
.RE
.PP

.PP
在文件 HiCanvas\&.cpp 第 1163 行定义\&.
.PP
.nf
1164     {
1165         if (BeginDrawing())
1166         {
1167             if (isSetColor) settextcolor(c);
1168             outtextxy(x, y, lpszText);
1169             int width = textwidth(lpszText);
1170             EndDrawing();
1171             return width;
1172         }
1173         return 0;
1174     }
.fi
.SS "int HiEasyX::Canvas::OutTextXY (int x, int y, TCHAR ch, bool isSetColor = \fCfalse\fP, COLORREF c = \fC0\fP)"

.PP
在文件 HiCanvas\&.cpp 第 1176 行定义\&.
.PP
.nf
1177     {
1178         if (BeginDrawing())
1179         {
1180             if (isSetColor) settextcolor(c);
1181             outtextxy(x, y, ch);
1182             int width = textwidth(ch);
1183             EndDrawing();
1184             return width;
1185         }
1186         return 0;
1187     }
.fi
.SS "int HiEasyX::Canvas::OutTextXY_Format (int x, int y, int _Size, LPCTSTR _Format,  \&.\&.\&.)"

.PP
在指定位置输出格式化文本 
.PP
\fB参数\fP
.RS 4
\fIx\fP 位置 
.br
\fIy\fP 位置 
.br
\fI_Size\fP 格式化文本最大长度 
.br
\fI_Format\fP 格式化字符串 
.br
\fI不定参数\fP 
.RE
.PP
\fB返回\fP
.RS 4
文本像素宽度 
.RE
.PP

.PP
在文件 HiCanvas\&.cpp 第 1189 行定义\&.
.PP
.nf
1190     {
1191         if (BeginDrawing())
1192         {
1193             va_list list;
1194             va_start(list, _Format);
1195             wchar_t* buf = new wchar_t[_Size];
1196             vswprintf_s(buf, _Size, _Format, list);
1197             va_end(list);
1198 
1199             outtextxy(x, y, buf);
1200             int width = textwidth(buf);
1201             delete[] buf;
1202 
1203             EndDrawing();
1204             return width;
1205         }
1206         return 0;
1207     }
.fi
.SS "void HiEasyX::Canvas::Pie (int left, int top, int right, int bottom, double stangle, double endangle, bool isSetColor = \fCfalse\fP, COLORREF c = \fC0\fP)"

.PP
在文件 HiCanvas\&.cpp 第 1027 行定义\&.
.PP
.nf
1028     {
1029         if (BeginDrawing())
1030         {
1031             if (isSetColor) setlinecolor(c);
1032             pie(left, top, right, bottom, stangle, endangle);
1033             EndDrawing();
1034         }
1035     }
.fi
.SS "void HiEasyX::Canvas::Pie (RECT rct, double stangle, double endangle, bool isSetColor = \fCfalse\fP, COLORREF c = \fC0\fP)"

.PP
在文件 HiCanvas\&.cpp 第 1037 行定义\&.
.PP
.nf
1038     {
1039         Pie(rct\&.left, rct\&.top, rct\&.right, rct\&.bottom, stangle, endangle, isSetColor, c);
1040     }
.fi
.SS "void HiEasyX::Canvas::PolyBezier (const POINT * points, int num, bool isSetColor = \fCfalse\fP, COLORREF c = \fC0\fP)"

.PP
在文件 HiCanvas\&.cpp 第 1143 行定义\&.
.PP
.nf
1144     {
1145         if (BeginDrawing())
1146         {
1147             if (isSetColor) setlinecolor(c);
1148             polybezier(points, num);
1149             EndDrawing();
1150         }
1151     }
.fi
.SS "void HiEasyX::Canvas::Polygon (const POINT * points, int num, bool isSetColor = \fCfalse\fP, COLORREF c = \fC0\fP)"

.PP
在文件 HiCanvas\&.cpp 第 1100 行定义\&.
.PP
.nf
1101     {
1102         if (BeginDrawing())
1103         {
1104             if (isSetColor) setlinecolor(c);
1105             polygon(points, num);
1106             EndDrawing();
1107         }
1108     }
.fi
.SS "void HiEasyX::Canvas::Polyline (const POINT * points, int num, bool isSetColor = \fCfalse\fP, COLORREF c = \fC0\fP)"

.PP
在文件 HiCanvas\&.cpp 第 1090 行定义\&.
.PP
.nf
1091     {
1092         if (BeginDrawing())
1093         {
1094             if (isSetColor) setlinecolor(c);
1095             polyline(points, num);
1096             EndDrawing();
1097         }
1098     }
.fi
.SS "IMAGE* HiEasyX::Canvas::Pt ()\fC [inline]\fP"

.PP
等价于 \fBGetImagePointer()\fP 
.PP
在文件 HiCanvas\&.h 第 262 行定义\&.
.PP
.nf
262 { return m_bBindToImgPointer ? m_pImg : this; }
.fi
.SS "void HiEasyX::Canvas::PutImageIn_Alpha (int x, int y, IMAGE * pImg, RECT crop = \fC{ 0 }\fP, BYTE alpha = \fC255\fP, bool bUseSrcAlpha = \fCfalse\fP, bool isCalculated = \fCfalse\fP)"

.PP
绘制图像到该画布 
.PP
\fB参数\fP
.RS 4
\fIx\fP 图像输入位置 
.br
\fIy\fP 图像输入位置 
.br
\fIpImg\fP 待输入图像 
.br
\fIcrop\fP 裁剪区域 
.br
\fIalpha\fP 叠加透明度 
.br
\fIbUseSrcAlpha\fP 是否使用原图透明度 
.br
\fIisCalculated\fP 原图是否已经混合透明度 
.RE
.PP

.PP
在文件 HiCanvas\&.cpp 第 1577 行定义\&.
.PP
.nf
1578     {
1579         int w, h;   // 原图像尺寸
1580         GetImageSize(pImg, &w, &h);
1581         if (BeginWindowTask())
1582         {
1583             CopyImage_Alpha(
1584                 x, y,
1585                 m_pBuf, m_nWidth, m_nHeight,
1586                 GetImageBuffer(pImg), w, h,
1587                 crop,
1588                 alpha, bUseSrcAlpha, isCalculated
1589             );
1590 
1591             EndWindowTask();
1592         }
1593     }
.fi
.SS "void HiEasyX::Canvas::PutPixel (int x, int y, COLORREF c)"

.PP
在文件 HiCanvas\&.cpp 第 716 行定义\&.
.PP
.nf
717     {
718         if (BeginDrawing())
719         {
720             putpixel(x, y, c);
721             EndDrawing();
722         }
723     }
.fi
.SS "void HiEasyX::Canvas::PutPixel_Direct (int x, int y, COLORREF c)"

.PP
直接操作显存绘制点 
.PP
在文件 HiCanvas\&.cpp 第 736 行定义\&.
.PP
.nf
737     {
738         if (BeginWindowTask())
739         {
740             c = BGR(c);
741             int index = 0;
742             if (IsValidPoint(x, y, &index))
743                 m_pBuf[index] = c;
744 
745             EndWindowTask();
746         }
747     }
.fi
.SS "void HiEasyX::Canvas::PutPixel_Direct_Alpha (int x, int y, COLORREF c)"

.PP
直接操作显存绘制带有透明度的点（使用 COLORREF 中的透明度） 
.PP
在文件 HiCanvas\&.cpp 第 749 行定义\&.
.PP
.nf
750     {
751         if (BeginWindowTask())
752         {
753             c = BGR(c);
754             int index = 0;
755             if (IsValidPoint(x, y, &index))
756             {
757                 m_pBuf[index] = MixAlphaColor(m_pBuf[index], c, false);
758             }
759 
760             EndWindowTask();
761         }
762     }
.fi
.SS "void HiEasyX::Canvas::Rectangle (int left, int top, int right, int bottom, bool isSetColor = \fCfalse\fP, COLORREF c = \fC0\fP)"

.PP
在文件 HiCanvas\&.cpp 第 779 行定义\&.
.PP
.nf
780     {
781         if (BeginDrawing())
782         {
783             if (isSetColor) setlinecolor(c);
784             rectangle(left, top, right, bottom);
785             EndDrawing();
786         }
787     }
.fi
.SS "void HiEasyX::Canvas::Rectangle (RECT rct, bool isSetColor = \fCfalse\fP, COLORREF c = \fC0\fP)"

.PP
在文件 HiCanvas\&.cpp 第 789 行定义\&.
.PP
.nf
790     {
791         Rectangle(rct\&.left, rct\&.top, rct\&.right, rct\&.bottom, isSetColor, c);
792     }
.fi
.SS "void HiEasyX::Canvas::RenderTo (int x, int y, IMAGE * pImg = \fCnullptr\fP, RECT crop = \fC{ 0 }\fP, BYTE alpha = \fC255\fP, bool bUseSrcAlpha = \fCfalse\fP, bool isCalculated = \fCfalse\fP)"

.PP
将该画布的图像绘制到另一画布中 
.PP
\fB参数\fP
.RS 4
\fIx\fP 绘制位置 
.br
\fIy\fP 绘制位置 
.br
\fIpImg\fP 目标绘制画布 
.br
\fIcrop\fP 裁剪区域（默认不裁剪） 
.br
\fIalpha\fP 叠加透明度 
.br
\fIbUseSrcAlpha\fP 是否使用此画布透明度 
.br
\fIisCalculated\fP 画布像素是否已经透明混合 
.RE
.PP

.PP
在文件 HiCanvas\&.cpp 第 435 行定义\&.
.PP
.nf
436     {
437         int w, h;   // 目标输出画布尺寸
438         GetImageSize(pImg, &w, &h);
439         if (BeginWindowTask())
440         {
441             CopyImage_Alpha(
442                 x, y,
443                 GetImageBuffer(pImg), w, h,
444                 m_pBuf, m_nWidth, m_nHeight,
445                 crop,
446                 alpha, bUseSrcAlpha, isCalculated
447             );
448 
449             EndWindowTask();
450         }
451     }
.fi
.SS "void HiEasyX::Canvas::Resize (int w, int h)\fC [override]\fP"

.PP
重设画布大小（若绑定了窗口，则不建议调用） 
.PP
\fB参数\fP
.RS 4
\fIw\fP 目标宽度 
.br
\fIh\fP 目标高度 
.RE
.PP

.PP
在文件 HiCanvas\&.cpp 第 366 行定义\&.
.PP
.nf
367     {
368         if (BeginWindowTask())
369         {
370             if (!(w * h))
371             {
372                 w = h = 1;
373             }
374 
375             if (m_bBindToImgPointer)
376             {
377                 ::Resize(m_pImg, w, h);
378             }
379             else
380             {
381                 IMAGE::Resize(w, h);
382             }
383 
384             EndWindowTask();
385             UpdateSizeInfo();
386         }
387     }
.fi
.SS "void HiEasyX::Canvas::RotateImage (double radian, COLORREF bkcolor = \fCBLACK\fP, bool autosize = \fCfalse\fP, bool highquality = \fCtrue\fP)"

.PP
EasyX 原生旋转函数 
.PP
\fB参数\fP
.RS 4
\fIradian\fP 旋转弧度 
.br
\fIbkcolor\fP 填充背景色 
.br
\fIautosize\fP 是否自适应旋转图像大小 
.br
\fIhighquality\fP 高质量 
.RE
.PP

.PP
在文件 HiCanvas\&.cpp 第 1595 行定义\&.
.PP
.nf
1596     {
1597         if (BeginWindowTask())
1598         {
1599             IMAGE* p = GetImagePointer();
1600             rotateimage(p, p, radian, bkcolor, autosize, highquality);
1601             BeginWindowTask();
1602         }
1603     }
.fi
.SS "void HiEasyX::Canvas::RotateImage_Alpha (double radian, COLORREF bkcolor = \fCBLACK\fP)"

.PP
旋转图像（保留 Alpha 信息） 
.PP
\fB参数\fP
.RS 4
\fIradian\fP 旋转弧度 
.br
\fIbkcolor\fP 填充背景色 
.RE
.PP

.PP
在文件 HiCanvas\&.cpp 第 1605 行定义\&.
.PP
.nf
1606     {
1607         operator=(HiEasyX::RotateImage_Alpha(GetImagePointer(), radian, bkcolor));
1608     }
.fi
.SS "void HiEasyX::Canvas::RoundRect (int left, int top, int right, int bottom, int ellipsewidth, int ellipseheight, bool isSetColor = \fCfalse\fP, COLORREF c = \fC0\fP)"

.PP
在文件 HiCanvas\&.cpp 第 949 行定义\&.
.PP
.nf
950     {
951         if (BeginDrawing())
952         {
953             if (isSetColor) setlinecolor(c);
954             roundrect(left, top, right, bottom, ellipsewidth, ellipseheight);
955             EndDrawing();
956         }
957     }
.fi
.SS "void HiEasyX::Canvas::RoundRect (RECT rct, int ellipsewidth, int ellipseheight, bool isSetColor = \fCfalse\fP, COLORREF c = \fC0\fP)"

.PP
在文件 HiCanvas\&.cpp 第 959 行定义\&.
.PP
.nf
960     {
961         RoundRect(rct\&.left, rct\&.top, rct\&.right, rct\&.bottom, ellipsewidth, ellipseheight, c, isSetColor);
962     }
.fi
.SS "void HiEasyX::Canvas::SetBkColor (COLORREF color)"

.PP
在文件 HiCanvas\&.cpp 第 676 行定义\&.
.PP
.nf
677     {
678         if (BeginDrawing())
679         {
680             setbkcolor(color);
681             EndDrawing();
682         }
683     }
.fi
.SS "void HiEasyX::Canvas::SetBkMode (int mode)"

.PP
在文件 HiCanvas\&.cpp 第 696 行定义\&.
.PP
.nf
697     {
698         if (BeginDrawing())
699         {
700             setbkmode(mode);
701             EndDrawing();
702         }
703     }
.fi
.SS "void HiEasyX::Canvas::SetColor (COLORREF color)"

.PP
设置前景色 
.PP
\fB参数\fP
.RS 4
\fIcolor\fP 前景色 
.RE
.PP

.PP
在文件 HiCanvas\&.cpp 第 1451 行定义\&.
.PP
.nf
1452     {
1453         if (BeginDrawing())
1454         {
1455             setcolor(color);
1456             EndDrawing();
1457         }
1458     }
.fi
.SS "void HiEasyX::Canvas::SetDefault ()"

.PP
设置绘图状态为原始状态 
.PP
在文件 HiCanvas\&.cpp 第 596 行定义\&.
.PP
.nf
597     {
598         if (BeginDrawing())
599         {
600             graphdefaults();
601             EndDrawing();
602         }
603     }
.fi
.SS "void HiEasyX::Canvas::SetFillColor (COLORREF color)"

.PP
在文件 HiCanvas\&.cpp 第 656 行定义\&.
.PP
.nf
657     {
658         if (BeginDrawing())
659         {
660             setfillcolor(color);
661             EndDrawing();
662         }
663     }
.fi
.SS "void HiEasyX::Canvas::SetFillStyle (BYTE * ppattern8x8)"

.PP
在文件 HiCanvas\&.cpp 第 547 行定义\&.
.PP
.nf
548     {
549         if (BeginDrawing())
550         {
551             setfillstyle(ppattern8x8);
552             EndDrawing();
553         }
554     }
.fi
.SS "void HiEasyX::Canvas::SetFillStyle (FILLSTYLE style)"

.PP
在文件 HiCanvas\&.cpp 第 529 行定义\&.
.PP
.nf
530     {
531         if (BeginDrawing())
532         {
533             setfillstyle(&style);
534             EndDrawing();
535         }
536     }
.fi
.SS "void HiEasyX::Canvas::SetFillStyle (int style, long hatch = \fC0\fP, IMAGE * ppattern = \fCnullptr\fP)"

.PP
在文件 HiCanvas\&.cpp 第 538 行定义\&.
.PP
.nf
539     {
540         if (BeginDrawing())
541         {
542             setfillstyle(style, hatch, ppattern);
543             EndDrawing();
544         }
545     }
.fi
.SS "void HiEasyX::Canvas::SetFont (int nHeight, int nWidth = \fC0\fP)"

.PP
设置字体大小 
.PP
\fB参数\fP
.RS 4
\fInHeight\fP 高度 
.br
\fInWidth\fP 宽度（为 0 时，自动与高度匹配） 
.RE
.PP

.PP
在文件 HiCanvas\&.cpp 第 1343 行定义\&.
.PP
.nf
1344     {
1345         if (BeginDrawing())
1346         {
1347             LOGFONT font;
1348             gettextstyle(&font);
1349             font\&.lfHeight = nHeight;
1350             font\&.lfWidth = nWidth;
1351             settextstyle(&font);
1352             EndDrawing();
1353         }
1354     }
.fi
.SS "void HiEasyX::Canvas::SetLineColor (COLORREF color)"

.PP
在文件 HiCanvas\&.cpp 第 616 行定义\&.
.PP
.nf
617     {
618         if (BeginDrawing())
619         {
620             setlinecolor(color);
621             EndDrawing();
622         }
623     }
.fi
.SS "void HiEasyX::Canvas::SetLineStyle (int style, int thickness = \fC1\fP, const DWORD * puserstyle = \fCnullptr\fP, DWORD userstylecount = \fC0\fP)"

.PP
在文件 HiCanvas\&.cpp 第 496 行定义\&.
.PP
.nf
497     {
498         if (BeginDrawing())
499         {
500             setlinestyle(style, thickness, puserstyle, userstylecount);
501             EndDrawing();
502         }
503     }
.fi
.SS "void HiEasyX::Canvas::SetLineStyle (LINESTYLE style)"

.PP
在文件 HiCanvas\&.cpp 第 487 行定义\&.
.PP
.nf
488     {
489         if (BeginDrawing())
490         {
491             setlinestyle(&style);
492             EndDrawing();
493         }
494     }
.fi
.SS "void HiEasyX::Canvas::SetLineThickness (int thickness)"

.PP
在文件 HiCanvas\&.cpp 第 505 行定义\&.
.PP
.nf
506     {
507         LINESTYLE s = GetLineStyle();
508         s\&.thickness = thickness;
509         SetLineStyle(s);
510     }
.fi
.SS "void HiEasyX::Canvas::SetPolyFillMode (int mode)"

.PP
在文件 HiCanvas\&.cpp 第 587 行定义\&.
.PP
.nf
588     {
589         if (BeginDrawing())
590         {
591             setpolyfillmode(mode);
592             EndDrawing();
593         }
594     }
.fi
.SS "void HiEasyX::Canvas::SetRop2 (int mode)"

.PP
在文件 HiCanvas\&.cpp 第 567 行定义\&.
.PP
.nf
568     {
569         if (BeginDrawing())
570         {
571             setrop2(mode);
572             EndDrawing();
573         }
574     }
.fi
.SS "void HiEasyX::Canvas::SetTextColor (COLORREF color)"

.PP
在文件 HiCanvas\&.cpp 第 636 行定义\&.
.PP
.nf
637     {
638         if (BeginDrawing())
639         {
640             settextcolor(color);
641             EndDrawing();
642         }
643     }
.fi
.SS "void HiEasyX::Canvas::SetTextEscapement (LONG lfEscapement)"

.PP
设置字符串的书写角度（单位 0\&.1 度） 
.PP
\fB参数\fP
.RS 4
\fIlfEscapement\fP 角度 
.RE
.PP

.PP
在文件 HiCanvas\&.cpp 第 1368 行定义\&.
.PP
.nf
1369     {
1370         if (BeginDrawing())
1371         {
1372             LOGFONT font;
1373             gettextstyle(&font);
1374             font\&.lfEscapement = lfEscapement;
1375             settextstyle(&font);
1376             EndDrawing();
1377         }
1378     }
.fi
.SS "void HiEasyX::Canvas::SetTextItalic (bool lfItalic)"

.PP
设置字体是否为斜体 
.PP
\fB参数\fP
.RS 4
\fIlfItalic\fP 是否使用斜体 
.RE
.PP

.PP
在文件 HiCanvas\&.cpp 第 1404 行定义\&.
.PP
.nf
1405     {
1406         if (BeginDrawing())
1407         {
1408             LOGFONT font;
1409             gettextstyle(&font);
1410             font\&.lfItalic = lfItalic;
1411             settextstyle(&font);
1412             EndDrawing();
1413         }
1414     }
.fi
.SS "void HiEasyX::Canvas::SetTextOrientation (LONG lfOrientation)"

.PP
设置每个字符的书写角度（单位 0\&.1 度） 
.PP
\fB参数\fP
.RS 4
\fIlfOrientation\fP 角度 
.RE
.PP

.PP
在文件 HiCanvas\&.cpp 第 1380 行定义\&.
.PP
.nf
1381     {
1382         if (BeginDrawing())
1383         {
1384             LOGFONT font;
1385             gettextstyle(&font);
1386             font\&.lfOrientation = lfOrientation;
1387             settextstyle(&font);
1388             EndDrawing();
1389         }
1390     }
.fi
.SS "void HiEasyX::Canvas::SetTextStrikeOut (bool lfStrikeOut)"

.PP
设置字体是否有删除线 
.PP
\fB参数\fP
.RS 4
\fIlfStrikeOut\fP 是否使用删除线 
.RE
.PP

.PP
在文件 HiCanvas\&.cpp 第 1428 行定义\&.
.PP
.nf
1429     {
1430         if (BeginDrawing())
1431         {
1432             LOGFONT font;
1433             gettextstyle(&font);
1434             font\&.lfStrikeOut = lfStrikeOut;
1435             settextstyle(&font);
1436             EndDrawing();
1437         }
1438     }
.fi
.SS "void HiEasyX::Canvas::SetTextStyle (int nHeight, int nWidth, LPCTSTR lpszFace)"

.PP
在文件 HiCanvas\&.cpp 第 1307 行定义\&.
.PP
.nf
1308     {
1309         if (BeginDrawing())
1310         {
1311             settextstyle(nHeight, nWidth, lpszFace);
1312             EndDrawing();
1313         }
1314     }
.fi
.SS "void HiEasyX::Canvas::SetTextStyle (int nHeight, int nWidth, LPCTSTR lpszFace, int nEscapement, int nOrientation, int nWeight, bool bItalic, bool bUnderline, bool bStrikeOut)"

.PP
在文件 HiCanvas\&.cpp 第 1316 行定义\&.
.PP
.nf
1317     {
1318         if (BeginDrawing())
1319         {
1320             settextstyle(nHeight, nWidth, lpszFace, nEscapement, nOrientation, nWeight, bItalic, bUnderline, bStrikeOut);
1321             EndDrawing();
1322         }
1323     }
.fi
.SS "void HiEasyX::Canvas::SetTextStyle (int nHeight, int nWidth, LPCTSTR lpszFace, int nEscapement, int nOrientation, int nWeight, bool bItalic, bool bUnderline, bool bStrikeOut, BYTE fbCharSet, BYTE fbOutPrecision, BYTE fbClipPrecision, BYTE fbQuality, BYTE fbPitchAndFamily)"

.PP
在文件 HiCanvas\&.cpp 第 1325 行定义\&.
.PP
.nf
1326     {
1327         if (BeginDrawing())
1328         {
1329             settextstyle(nHeight, nWidth, lpszFace, nEscapement, nOrientation, nWeight, bItalic, bUnderline, bStrikeOut, fbCharSet, fbOutPrecision, fbClipPrecision, fbQuality, fbPitchAndFamily);
1330             EndDrawing();
1331         }
1332     }
.fi
.SS "void HiEasyX::Canvas::SetTextStyle (LOGFONT font)"

.PP
在文件 HiCanvas\&.cpp 第 1334 行定义\&.
.PP
.nf
1335     {
1336         if (BeginDrawing())
1337         {
1338             settextstyle(&font);
1339             EndDrawing();
1340         }
1341     }
.fi
.SS "void HiEasyX::Canvas::SetTextUnderline (bool lfUnderline)"

.PP
设置字体是否有下划线 
.PP
\fB参数\fP
.RS 4
\fIlfUnderline\fP 是否使用下划线 
.RE
.PP

.PP
在文件 HiCanvas\&.cpp 第 1416 行定义\&.
.PP
.nf
1417     {
1418         if (BeginDrawing())
1419         {
1420             LOGFONT font;
1421             gettextstyle(&font);
1422             font\&.lfUnderline = lfUnderline;
1423             settextstyle(&font);
1424             EndDrawing();
1425         }
1426     }
.fi
.SS "void HiEasyX::Canvas::SetTextWeight (LONG lfWeight)"

.PP
设置字符的笔画粗细（范围 默认 0 ~ 1000 最粗） 
.PP
\fB参数\fP
.RS 4
\fIlfWeight\fP 粗细 
.RE
.PP

.PP
在文件 HiCanvas\&.cpp 第 1392 行定义\&.
.PP
.nf
1393     {
1394         if (BeginDrawing())
1395         {
1396             LOGFONT font;
1397             gettextstyle(&font);
1398             font\&.lfWeight = lfWeight;
1399             settextstyle(&font);
1400             EndDrawing();
1401         }
1402     }
.fi
.SS "void HiEasyX::Canvas::SetTypeface (LPCTSTR lpsz)"

.PP
设置使用字体的名称 
.PP
\fB参数\fP
.RS 4
\fIlpsz\fP 字体名称 
.RE
.PP

.PP
在文件 HiCanvas\&.cpp 第 1356 行定义\&.
.PP
.nf
1357     {
1358         if (BeginDrawing())
1359         {
1360             LOGFONT font;
1361             gettextstyle(&font);
1362             lstrcpy(font\&.lfFaceName, lpsz);
1363             settextstyle(&font);
1364             EndDrawing();
1365         }
1366     }
.fi
.SS "void HiEasyX::Canvas::SolidCircle (int x, int y, int radius, bool isSetColor = \fCfalse\fP, COLORREF c = \fC0\fP)"

.PP
在文件 HiCanvas\&.cpp 第 867 行定义\&.
.PP
.nf
868     {
869         if (BeginDrawing())
870         {
871             if (isSetColor) setfillcolor(c);
872             solidcircle(x, y, radius);
873             EndDrawing();
874         }
875     }
.fi
.SS "void HiEasyX::Canvas::SolidEllipse (int left, int top, int right, int bottom, bool isSetColor = \fCfalse\fP, COLORREF c = \fC0\fP)"

.PP
在文件 HiCanvas\&.cpp 第 920 行定义\&.
.PP
.nf
921     {
922         if (BeginDrawing())
923         {
924             if (isSetColor) setfillcolor(c);
925             solidellipse(left, top, right, bottom);
926             EndDrawing();
927         }
928     }
.fi
.SS "void HiEasyX::Canvas::SolidEllipse (RECT rct, bool isSetColor = \fCfalse\fP, COLORREF c = \fC0\fP)"

.PP
在文件 HiCanvas\&.cpp 第 930 行定义\&.
.PP
.nf
931     {
932         SolidEllipse(rct\&.left, rct\&.top, rct\&.right, rct\&.bottom, isSetColor, c);
933     }
.fi
.SS "void HiEasyX::Canvas::SolidPie (int left, int top, int right, int bottom, double stangle, double endangle, bool isSetColor = \fCfalse\fP, COLORREF c = \fC0\fP)"

.PP
在文件 HiCanvas\&.cpp 第 1061 行定义\&.
.PP
.nf
1062     {
1063         if (BeginDrawing())
1064         {
1065             if (isSetColor) setfillcolor(c);
1066             solidpie(left, top, right, bottom, stangle, endangle);
1067             EndDrawing();
1068         }
1069     }
.fi
.SS "void HiEasyX::Canvas::SolidPie (RECT rct, double stangle, double endangle, bool isSetColor = \fCfalse\fP, COLORREF c = \fC0\fP)"

.PP
在文件 HiCanvas\&.cpp 第 1071 行定义\&.
.PP
.nf
1072     {
1073         SolidPie(rct\&.left, rct\&.top, rct\&.right, rct\&.bottom, stangle, endangle, isSetColor, c);
1074     }
.fi
.SS "void HiEasyX::Canvas::SolidPolygon (const POINT * points, int num, bool isSetColor = \fCfalse\fP, COLORREF c = \fC0\fP)"

.PP
在文件 HiCanvas\&.cpp 第 1124 行定义\&.
.PP
.nf
1125     {
1126         if (BeginDrawing())
1127         {
1128             if (isSetColor) setfillcolor(c);
1129             solidpolygon(points, num);
1130             EndDrawing();
1131         }
1132     }
.fi
.SS "void HiEasyX::Canvas::SolidRectangle (int left, int top, int right, int bottom, bool isSetColor = \fCfalse\fP, COLORREF c = \fC0\fP)"

.PP
在文件 HiCanvas\&.cpp 第 814 行定义\&.
.PP
.nf
815     {
816         if (BeginDrawing())
817         {
818             if (isSetColor) setfillcolor(c);
819             solidrectangle(left, top, right, bottom);
820             EndDrawing();
821         }
822     }
.fi
.SS "void HiEasyX::Canvas::SolidRectangle (RECT rct, bool isSetColor = \fCfalse\fP, COLORREF c = \fC0\fP)"

.PP
在文件 HiCanvas\&.cpp 第 824 行定义\&.
.PP
.nf
825     {
826         SolidRectangle(rct\&.left, rct\&.top, rct\&.right, rct\&.bottom, isSetColor, c);
827     }
.fi
.SS "void HiEasyX::Canvas::SolidRoundRect (int left, int top, int right, int bottom, int ellipsewidth, int ellipseheight, bool isSetColor = \fCfalse\fP, COLORREF c = \fC0\fP)"

.PP
在文件 HiCanvas\&.cpp 第 983 行定义\&.
.PP
.nf
984     {
985         if (BeginDrawing())
986         {
987             if (isSetColor) setfillcolor(c);
988             solidroundrect(left, top, right, bottom, ellipsewidth, ellipseheight);
989             EndDrawing();
990         }
991     }
.fi
.SS "void HiEasyX::Canvas::SolidRoundRect (RECT rct, int ellipsewidth, int ellipseheight, bool isSetColor = \fCfalse\fP, COLORREF c = \fC0\fP)"

.PP
在文件 HiCanvas\&.cpp 第 993 行定义\&.
.PP
.nf
994     {
995         SolidRoundRect(rct\&.left, rct\&.top, rct\&.right, rct\&.bottom, ellipsewidth, ellipseheight, c, isSetColor);
996     }
.fi
.SS "int HiEasyX::Canvas::TextHeight (LPCTSTR lpszText)"

.PP
在文件 HiCanvas\&.cpp 第 1231 行定义\&.
.PP
.nf
1232     {
1233         if (BeginDrawing())
1234         {
1235             int width = textheight(lpszText);
1236             EndDrawing();
1237             return width;
1238         }
1239         return 0;
1240     }
.fi
.SS "int HiEasyX::Canvas::TextHeight (TCHAR c)"

.PP
在文件 HiCanvas\&.cpp 第 1242 行定义\&.
.PP
.nf
1243     {
1244         if (BeginDrawing())
1245         {
1246             int width = textheight(c);
1247             EndDrawing();
1248             return width;
1249         }
1250         return 0;
1251     }
.fi
.SS "int HiEasyX::Canvas::TextWidth (LPCTSTR lpszText)"

.PP
获取文本像素宽度 
.PP
\fB参数\fP
.RS 4
\fIlpszText\fP 文本 
.RE
.PP
\fB返回\fP
.RS 4
获取文本像素宽度 
.RE
.PP

.PP
在文件 HiCanvas\&.cpp 第 1209 行定义\&.
.PP
.nf
1210     {
1211         if (BeginDrawing())
1212         {
1213             int width = textwidth(lpszText);
1214             EndDrawing();
1215             return width;
1216         }
1217         return 0;
1218     }
.fi
.SS "int HiEasyX::Canvas::TextWidth (TCHAR c)"

.PP
在文件 HiCanvas\&.cpp 第 1220 行定义\&.
.PP
.nf
1221     {
1222         if (BeginDrawing())
1223         {
1224             int width = textwidth(c);
1225             EndDrawing();
1226             return width;
1227         }
1228         return 0;
1229     }
.fi
.SS "void HiEasyX::Canvas::UpdateSizeInfo ()"

.PP
.nf

    重新加载图像尺寸信息
.fi
.PP
.PP
.PP
.nf
备注：
    若绑定了图像指针，当外部调整图像大小后，须调用此函数
.fi
.PP
 
.PP
在文件 HiCanvas\&.cpp 第 349 行定义\&.
.PP
.nf
350     {
351         m_pBuf = GetImageBuffer(GetImagePointer());
352 
353         if (m_bBindToImgPointer)
354         {
355             GetImageSize(m_pImg, &m_nWidth, &m_nHeight);
356         }
357         else
358         {
359             m_nWidth = IMAGE::getwidth();
360             m_nHeight = IMAGE::getheight();
361         }
362 
363         m_nBufSize = m_nWidth * m_nHeight;
364     }
.fi
.SS "void HiEasyX::Canvas::ZoomImage_Alpha (int nW, int nH = \fC0\fP)"

.PP
缩放图像（双线性插值，保留透明度信息） 
.PP
\fB参数\fP
.RS 4
\fInW\fP 目标宽度 
.br
\fInH\fP 目标高度（为 0 则根据宽度按比例缩放） 
.RE
.PP

.PP
在文件 HiCanvas\&.cpp 第 1628 行定义\&.
.PP
.nf
1629     {
1630         if (m_bBindToImgPointer)
1631         {
1632             if (BeginWindowTask())
1633             {
1634                 *m_pImg = HiEasyX::ZoomImage_Alpha(m_pImg, nW, nH);
1635                 UpdateSizeInfo();
1636 
1637                 EndWindowTask();
1638             }
1639         }
1640         else
1641         {
1642             operator=(HiEasyX::ZoomImage_Alpha(this, nW, nH));
1643         }
1644     }
.fi
.SS "void HiEasyX::Canvas::ZoomImage_Rough_Alpha (int nW, int nH = \fC0\fP)"

.PP
缩放图像（粗糙的、即不插值的缩放，保留透明度信息） 
.PP
\fB参数\fP
.RS 4
\fInW\fP 目标宽度 
.br
\fInH\fP 目标高度（为 0 则根据宽度按比例缩放） 
.RE
.PP

.PP
在文件 HiCanvas\&.cpp 第 1610 行定义\&.
.PP
.nf
1611     {
1612         if (m_bBindToImgPointer)
1613         {
1614             if (BeginWindowTask())
1615             {
1616                 *m_pImg = HiEasyX::ZoomImage_Rough_Alpha(m_pImg, nW, nH);
1617                 UpdateSizeInfo();
1618 
1619                 EndWindowTask();
1620             }
1621         }
1622         else
1623         {
1624             operator=(HiEasyX::ZoomImage_Rough_Alpha(this, nW, nH));
1625         }
1626     }
.fi
.SS "void HiEasyX::Canvas::ZoomImage_Win32_Alpha (int nW, int nH = \fC0\fP)"

.PP
缩放图像（基于 Win32 API，比较快，保留透明度信息） 
.PP
\fB参数\fP
.RS 4
\fInW\fP 目标宽度 
.br
\fInH\fP 目标高度（为 0 则根据宽度按比例缩放） 
.RE
.PP

.PP
在文件 HiCanvas\&.cpp 第 1646 行定义\&.
.PP
.nf
1647     {
1648         if (m_bBindToImgPointer)
1649         {
1650             if (BeginWindowTask())
1651             {
1652                 *m_pImg = HiEasyX::ZoomImage_Win32_Alpha(m_pImg, nW, nH);
1653                 UpdateSizeInfo();
1654             }
1655         }
1656         else
1657         {
1658             operator=(HiEasyX::ZoomImage_Win32_Alpha(this, nW, nH));
1659         }
1660     }
.fi
.SH "友元及相关函数文档"
.PP 
.SS "void BindWindowCanvas (\fBCanvas\fP *, HWND)\fC [friend]\fP"

.PP
.nf

    绑定窗口画布指针
.fi
.PP
.PP
.PP
.nf
 备注：
    绑定后，使用画布绘图时将自动开启任务，无需用户开启，但不会自动刷新屏幕
.fi
.PP
.PP
\fB参数\fP
.RS 4
\fIpCanvas\fP 画布指针 
.br
\fIhWnd\fP 窗口句柄（为空表示当前活动窗口） 
.RE
.PP

.PP
在文件 HiWindow\&.cpp 第 301 行定义\&.
.PP
.nf
302     {
303         int index = GetWindowIndex(hWnd);
304         if (IsAliveWindow(index))
305         {
306             g_vecWindows[index]\&.pBufferImgCanvas = pCanvas;
307             pCanvas->BindToWindow(g_vecWindows[index]\&.hWnd, g_vecWindows[index]\&.pBufferImg);
308         }
309     }
.fi
.SH "类成员变量说明"
.PP 
.SS "bool HiEasyX::Canvas::m_bAutoMarkFlushWindow = true\fC [protected]\fP"

.PP
绑定到窗口时，标记是否在绘制后自动设置需要更新双缓冲 
.PP
在文件 HiCanvas\&.h 第 146 行定义\&.
.SS "bool HiEasyX::Canvas::m_bBatchDraw\fC [protected]\fP"

.PP
是否启用了批量绘制 
.PP
在文件 HiCanvas\&.h 第 137 行定义\&.
.SS "bool HiEasyX::Canvas::m_bBindToImgPointer\fC [protected]\fP"

.PP
该画布是否绑定到图像指针 
.PP
在文件 HiCanvas\&.h 第 134 行定义\&.
.SS "bool HiEasyX::Canvas::m_bGPAA = true\fC [protected]\fP"

.PP
GDI+ 绘图时是否抗锯齿 
.PP
在文件 HiCanvas\&.h 第 143 行定义\&.
.SS "bool HiEasyX::Canvas::m_bGPAlpha = false\fC [protected]\fP"

.PP
GDI+ 绘图时是否启用透明度 
.PP
在文件 HiCanvas\&.h 第 142 行定义\&.
.SS "COLORREF HiEasyX::Canvas::m_cGPFillColor = WHITE\fC [protected]\fP"

.PP
GDI+ 绘图时使用的填充颜色 
.PP
在文件 HiCanvas\&.h 第 140 行定义\&.
.SS "COLORREF HiEasyX::Canvas::m_cGPLineColor = WHITE\fC [protected]\fP"

.PP
GDI+ 绘图时使用的线条颜色 
.PP
在文件 HiCanvas\&.h 第 139 行定义\&.
.SS "float HiEasyX::Canvas::m_fGPLineWidth = 1\&.f\fC [protected]\fP"

.PP
GDI+ 绘图时的线条宽度 
.PP
在文件 HiCanvas\&.h 第 141 行定义\&.
.SS "HWND HiEasyX::Canvas::m_hBindWindow\fC [protected]\fP"

.PP
绑定到的窗口 
.PP
在文件 HiCanvas\&.h 第 145 行定义\&.
.SS "int HiEasyX::Canvas::m_nBufSize\fC [protected]\fP"

.PP
图像面积 
.PP
在文件 HiCanvas\&.h 第 132 行定义\&.
.SS "int HiEasyX::Canvas::m_nHeight\fC [protected]\fP"

.PP
图像宽高 
.PP
在文件 HiCanvas\&.h 第 131 行定义\&.
.SS "int HiEasyX::Canvas::m_nWidth\fC [protected]\fP"

.PP
在文件 HiCanvas\&.h 第 131 行定义\&.
.SS "DWORD* HiEasyX::Canvas::m_pBuf = nullptr\fC [protected]\fP"

.PP
图像内存指针 
.PP
在文件 HiCanvas\&.h 第 130 行定义\&.
.SS "IMAGE* HiEasyX::Canvas::m_pImg\fC [protected]\fP"

.PP
画布绑定的图像指针（若画布绑定到指针） 
.PP
在文件 HiCanvas\&.h 第 135 行定义\&.
.SS "\fBDrawingProperty\fP HiEasyX::Canvas::m_property\fC [protected]\fP"

.PP
保存外界绘图属性（用于保存旧的绘图对象指针） 
.PP
在文件 HiCanvas\&.h 第 128 行定义\&.

.SH "作者"
.PP 
由 Doyxgen 通过分析 HiEasyX 的 源代码自动生成\&.
